<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>__labs__</title><link href="https://dunderlabs.github.io/" rel="alternate"></link><link href="https://dunderlabs.github.io/feeds/git.atom.xml" rel="self"></link><id>https://dunderlabs.github.io/</id><updated>2016-07-26T22:09:00-03:00</updated><entry><title>Eu deveria usar PYTHONOPTIMIZE?</title><link href="https://dunderlabs.github.io/eu-deveria-usar-pythonoptimize.html" rel="alternate"></link><updated>2016-07-26T22:09:00-03:00</updated><author><name>Patrick Mazulo</name></author><id>tag:dunderlabs.github.io,2016-07-26:eu-deveria-usar-pythonoptimize.html</id><summary type="html">&lt;p&gt;&lt;img alt="Créditos da imagem" src="https://dunderlabs.github.io/images/posts/pythonoptimize.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;Créditos da imagem: &lt;a href="http://blog.ziade.org/2015/11/25/should-i-use-pythonoptimize/"&gt;http://blog.ziade.org/2015/11/25/should-i-use-pythonoptimize/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Eu deveria usar PYTHONOPTIMIZE?&lt;/h2&gt;
&lt;p&gt;Ontem, eu estava revisando alguns códigos para os nossos projetos e em um PR eu vi algo ligeiramente similar a isso:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="nb"&gt;hasattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SomeObject&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;some_attribute&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;SomeObject&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;some_attribute&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;AssertionError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;SomeObject&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;do_something_else&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Não me levou a crer que seria uma boa ideia depender do &lt;code&gt;assert&lt;/code&gt; porque quando Python é executado usando a flag &lt;strong&gt;PYTHONOPTIMIZE&lt;/strong&gt;, que você pode ativar com o variável de ambiente de mesmo nome ou com &lt;code&gt;-O&lt;/code&gt; ou &lt;code&gt;-OO&lt;/code&gt;, todas as declarações de &lt;code&gt;assert&lt;/code&gt; são retiradas do código.&lt;/p&gt;
&lt;p&gt;Para minha surpresa, muitas pessoas estão ignorando &lt;code&gt;-O&lt;/code&gt; e &lt;code&gt;-OO&lt;/code&gt; dizendo que ninguém usa essas flags em produção, e que o código que contém asserts é bom.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PYTHONOPTIMIZE&lt;/strong&gt; tem três valores possíveis: &lt;strong&gt;0&lt;/strong&gt;, &lt;strong&gt;1&lt;/strong&gt; (-O) or &lt;strong&gt;2&lt;/strong&gt; (-OO). &lt;strong&gt;0&lt;/strong&gt; é o default, onde nada acontece.&lt;/p&gt;
&lt;p&gt;Quando o valor é &lt;strong&gt;1&lt;/strong&gt;, é isso o que acontece:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;asserts são removidos&lt;/li&gt;
&lt;li&gt;os arquivos bytecode gerados estão usando a extensão &lt;strong&gt;.pyo&lt;/strong&gt; ao invés de &lt;strong&gt;.pyc&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sys.flags.optimize&lt;/strong&gt; é setado para 1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;strong&gt;debug&lt;/strong&gt;&lt;/strong&gt; é setado para False&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;E para &lt;strong&gt;2&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tudo que o &lt;strong&gt;1&lt;/strong&gt; faz&lt;/li&gt;
&lt;li&gt;docstrings são removidas&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A meu conhecimento, uma razão antiga para rodar com a flag &lt;strong&gt;-O&lt;/strong&gt; era produzir um código bytecode mais eficiente, mas como falei isso não é mais verdade.&lt;/p&gt;
&lt;p&gt;Um outro comportamento que mudou está relacionado ao &lt;strong&gt;pdb&lt;/strong&gt;: você não poderia rodar um debugging passo-a-passo quando &lt;strong&gt;PYTHONOPTIMIZE&lt;/strong&gt; estiver ativado.&lt;/p&gt;
&lt;p&gt;Por último, a questão &lt;strong&gt;.pyo&lt;/strong&gt; vs &lt;strong&gt;.pyc&lt;/strong&gt; deve sumir um dia, de acordo com a &lt;a href="https://www.python.org/dev/peps/pep-0488"&gt;PEP 488&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Então o que faz isso nos deixar? Há alguma boa razão para usar essas flags?&lt;/p&gt;
&lt;p&gt;Algumas aplicações aproveitam a flag &lt;strong&gt;&lt;strong&gt;debug&lt;/strong&gt;&lt;/strong&gt; para oferecer dois modos de execução. Um com mais informações de debug, ou um comportamento diferente quando um erro é encontrado.&lt;/p&gt;
&lt;p&gt;Esse é o caso para o pyglet, de acordo com a &lt;a href="http://pyglet.readthedocs.org/en/latest/programming_guide/debug.html#error-checking"&gt;documentação dele&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Algumas empresas também estão usando o modo &lt;strong&gt;-O&lt;/strong&gt; para ligeiramente reduzir o consumo de memória ao rodar aplicações. Esse parece ser o caso no YouTube.&lt;/p&gt;
&lt;p&gt;E é inteiramente possível que o próprio Python, no futuro, adicione algumas novas otimizações por trás dessa flag.&lt;/p&gt;
&lt;p&gt;Então, sim, mesmo que você não use essas opções de flags, é uma boa prática assegurar que seu código python está testado com todos os possíveis valores para &lt;strong&gt;PYTHONOPTIMIZE&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;É fácil demais, apenas rode seus testes com &lt;strong&gt;-O&lt;/strong&gt; e &lt;strong&gt;-OO&lt;/strong&gt; e sem, e assegure que seu código não depende de docstrings ou assertions.&lt;/p&gt;
&lt;p&gt;Se você tem dependências em algum deles, tenha certeza que seu código trata elegamentemente o modo otimizado, ou lança um erro no início explicando porque você não está compatível com ele.&lt;/p&gt;
&lt;p&gt;Agradecimentos a Brett Cannon, Michael Foord e outros pelo feedback no Twitter sobre este assunto.&lt;/p&gt;
&lt;p&gt;Dúvidas e/ou críticas, só visitar os comentários mais abaixo. Valeu pessoal, e até a próxima!&lt;/p&gt;
&lt;p&gt;Referências:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.ziade.org/2015/11/25/should-i-use-pythonoptimize/"&gt;Post original&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="python"></category><category term="optimization"></category><category term="translations"></category></entry><entry><title>Porque eu "commito" tanto</title><link href="https://dunderlabs.github.io/porque-eu-commito-tanto.html" rel="alternate"></link><updated>2016-06-27T18:12:00-03:00</updated><author><name>Patrick Mazulo</name></author><id>tag:dunderlabs.github.io,2016-06-27:porque-eu-commito-tanto.html</id><summary type="html">&lt;p&gt;&lt;img alt="Créditos da imagem" src="https://dunderlabs.github.io/images/posts/in-case-of-fire-1-git-commit-2-git-push-3-leave-building2.png" /&gt;&lt;/p&gt;
&lt;p&gt;Créditos da imagem: &lt;a href="https://hikaruzone.wordpress.com/2015/10/06/in-case-of-fire-1-git-commit-2-git-push-3-leave-building/"&gt;https://hikaruzone.wordpress.com/2015/10/06/in-case-of-fire-1-git-commit-2-git-push-3-leave-building/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Porque eu faço muitos git commit&lt;/h2&gt;
&lt;p&gt;Recentemente me juntei a um novo projeto, e um dos meus colegas de equipe me perguntou: "Porque você 'commita' tanto?". Eu decidi escrever este post para explicar meus motivos para ele e para qualquer outra pessoa que possa se deparar com meu trabalho no futuro.&lt;/p&gt;
&lt;h3&gt;Commits pequenos podem ser seu melhor amigo.&lt;/h3&gt;
&lt;p&gt;Assim como funções, commits pequenos focam em uma coisa: uma simples mudança. Isso força nossa mensagem do commit ser mais descritiva (desculpa caras, "fixed some stuff" não está sendo nada descritivo).
Vamos dar uma olhada neste exemplo:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git commit -am &lt;span class="s2"&gt;&amp;quot;Updated &amp;#39;Contact us&amp;#39; to &amp;#39;Need Help? Contact Us!&amp;#39;&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Neste caso, você pode simplesmente olhar as mudanças feitas no commit, mas porque olhar no código quando a descrição está ali na sua frente? Commits pequenos tornam extremamente fácil encontrar uma mudança específica que entrou, especialmente quando tiver uma lista delas para analisar. Também tornam simples de ver como o projeto foi construído, pedaço por pedaço.&lt;/p&gt;
&lt;h4&gt;1. Simplificam a revisão do código.&lt;/h4&gt;
&lt;p&gt;Commits pequenos tornam revisões de código muito mais fáceis. Permitem que você revise as mudanças, umas de cada vez, e compartilhe da mentalidade do autor. Os commits contam uma história, como se o autor estivesse explicando as mudanças para uma pessoa.&lt;/p&gt;
&lt;h4&gt;2. Ajudam você a compartilhar conhecimento.&lt;/h4&gt;
&lt;p&gt;Recentemente, eu aprendi que adicionar uma quebra de linha depois da declaração de um &lt;code&gt;return&lt;/code&gt; em JavaScript é a mesma coisa que não retornar nada (se você ficou curioso, veja &lt;a href="http://stackoverflow.com/a/8528606"&gt;esta resposta no Stack Overflow&lt;/a&gt; para a explicação). Eu removi a quebra de linha e comitei o resultado:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git commit -am &lt;span class="s2"&gt;&amp;quot;A return followed by a line break doesn&amp;#39;t actually return anything&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Graças aos pequeno commits, fui capaz de compartilhar esse conhecimento com meus colegas de equipe, sabendo que estaria salvo para sempre. Se há uma coisa que eu aprendi como um programador, é que há uma razão para tudo. Algumas vezes, o raciocínio não está claro e o comentário do código não faz sentido (pode imaginar cada &lt;code&gt;return&lt;/code&gt; de funções JavaScript tendo um comentário dizendo "Quebra de linha não vão retornar esse dado"). Pequenos commits ajudam a preencher esta lacuna.&lt;/p&gt;
&lt;h4&gt;3. Podem ajudar a consertar seus erros.&lt;/h4&gt;
&lt;p&gt;Nenhum desenvolvedor é perfeito. Algumas vezes, nós vamos pelo caminho errado e percebemos que algo que tentamos apenas não funciona. Talvez tentamos pôr em negrito algum texto ao adicionaar uma classe CSS e ajustando algumas propriedades, mas os resultados não parecem bons. E agora?&lt;/p&gt;
&lt;p&gt;Poderíamos manualmente desfazer a mudança, mas é fácil esquecer de algo (por exemplo, você pode remove a classe CSS do elemento HTML, mas esquecer de remover a definição no arquivo CSS). &lt;code&gt;git revert&lt;/code&gt; é uma maneira extremamente fácil de desfazer uma mudança sem ter que lembrar do estado inicial.&lt;/p&gt;
&lt;p&gt;De modo semelhante, cada um de nós já escreveu um bug, e também consertou um bug enquanto introduzia mais três. Normalmente, somos capazes de encontrar a raiz do problema através do uso de breakpoints e reanalisar a problemática da lógica. No entanto, existem vezes onde essa problemática simplesmente não pode ser descoberta, não importa quais passos de debug você faça.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git bisect&lt;/code&gt; está aqui para salvar o dia! Ele primeiro pede para que você forneça um "bom" commit (um que não tenha o bug em questão), e um "mau" commit (normalmente, é o último commit). Ele então executa uma busca binária, testando vários commits como "bom" ou "mau".&lt;/p&gt;
&lt;p&gt;É extremamente importante que cada commit esteja "compilável" e todos os testes passem. Por outro lado, será impossível verificar se um commit é "bom" ou "mau". No caso em que um commit quebrado se infiltrar (vindo de um colega da equipe, claro, porque nós somos bons rapazes e moças), &lt;code&gt;git bisect skip&lt;/code&gt; pode ser usado para saltar sobre ele (apenas cruze seus dedos para que este commit não seja a causa do bug). No fim, &lt;code&gt;git bisect skip&lt;/code&gt; retornará o commit que introduziu o bug. O pedaço problemático de código deve estar completamente obvio, e uma correção para ele já deve estar sendo preparada.&lt;/p&gt;
&lt;h4&gt;4. Me protegem nas apresentações.&lt;/h4&gt;
&lt;p&gt;Se eu ganhasse um centavo por cada vez que tive um 'brancão' sobre as coisas que fiz no trabalho no dia anterior durante uma apresentação, estaria milionário. Uma vez tentei fazer uma lista das coisas que eu fiz durante o dia, mas era tedioso — e redundante, já que meus pequenos commits compartilhavam da mesma informação. E claro, ninguém quer ser aquele cara que tem uma longa lista das coisas que ele trabalhou, mas ir folheando pelo histórico de commits é uma boa maneira de refrescar a memória.&lt;/p&gt;
&lt;h4&gt;5. Me permitem selecionar as mudanças.&lt;/h4&gt;
&lt;p&gt;Considere este cenário: enquanto trabalha numa tarefa separada, Joe Bob adicionou algumas novas strings aos arquivos de tradução que acabou de receber. Ele também começou a incorporar essas traduções nas views dele, mas ele continua tendo testes falhando. Susan iniciou a tarefa dela e percebeu que precisa algumas dessas strings. Não faria sentido fazer um merge da branch do Joe Bob com a dela, sendo que ele ainda está trabalhando nesta branch. Susan poderia apenas redefinir essas traduções, mas ela tem medo do temido merge conflict. Sendo que Joe Bob usa pequenos commits, Susan pode selecionar o commit que Joe Bob introduziu as traduções ao executar o comando:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git cherry-pick some-hash
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;Resumindo.&lt;/h4&gt;
&lt;p&gt;Não tem problema em ir pelo caminho errado, e em seguida, reverter as alterações. Ninguém se importa com pequenos erros estúpidos — na verdade isso mostra que você se importa em melhorar o projeto e, por fim, você mesmo. Se você está contribuindo para um projeto open source, normalmente é melhor ter um commit por feature ou correção. Para ter o melhor dos dois mundos, você pode &lt;a href="http://makandracards.com/makandra/527-squash-several-git-commits-into-a-single-commit"&gt;dar um squash de todos os seus pequenos commits em um só&lt;/a&gt; antes de você publicar suas mudanças. E para qualquer um que estiver curioso, eu já estive em projetos com bem mais de 20000 commits, e nunca tive problemas de lentidão com git.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;E você, commita muito?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Dúvidas e/ou críticas, só visitar os comentários mais abaixo. Valeu pessoal, e até a próxima!&lt;/p&gt;
&lt;p&gt;Referências:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://spin.atomicobject.com/2015/11/11/all-the-commits/"&gt;Post original&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="git"></category><category term="good practices"></category><category term="translations"></category></entry></feed>