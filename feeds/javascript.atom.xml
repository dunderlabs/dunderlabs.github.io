<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>__labs__</title><link href="https://dunderlabs.github.io/" rel="alternate"></link><link href="https://dunderlabs.github.io/feeds/javascript.atom.xml" rel="self"></link><id>https://dunderlabs.github.io/</id><updated>2017-04-04T02:15:00-03:00</updated><entry><title>Map e Set: objetos que você deve conhecer em JavaScript</title><link href="https://dunderlabs.github.io/map-e-set-objetos-que-voce-deve-conhecer-em-javascript.html" rel="alternate"></link><updated>2017-04-04T02:15:00-03:00</updated><author><name>Nilton Cesar</name></author><id>tag:dunderlabs.github.io,2017-04-04:map-e-set-objetos-que-voce-deve-conhecer-em-javascript.html</id><summary type="html">&lt;p&gt;&lt;img alt="Dentro de um objeto Map" src="https://dunderlabs.github.io/images/posts/map-e-set-objetos-que-voce-deve-conhecer-em-javascript/post-cover.png" /&gt;&lt;/p&gt;
&lt;p&gt;Olá, dev amados!!!
Gostaria de abordar aqui alguns objetos desconhecidos pela maioria dos desenvolvedores JavaScript, mas que podem ser bastante úteis.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Mas porquê usá-los?!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Você não é obrigado a usá-los. Na verdade, os objetos mencionados são parecidos com objetos já conhecidos como &lt;code&gt;Object&lt;/code&gt; e &lt;code&gt;Array&lt;/code&gt;, porém de certa forma &lt;em&gt;melhorados&lt;/em&gt;. Cabe somente a você, desenvolvedor, decidir quando/se será sábio usá-los e onde.&lt;/p&gt;
&lt;h2&gt;Map&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Map&lt;/code&gt; é muito semelhante a &lt;code&gt;Object&lt;/code&gt;: uma coleção de pares chave-valor, sendo possível adicionar novos pares, acessar, modificar e deletá-los. Porém, com duas fundamentais diferenças:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;qualquer objeto pode ser uma chave&lt;/li&gt;
&lt;li&gt;um &lt;code&gt;Map&lt;/code&gt; guarda a ordem dos pares&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ok, talvez a primeira não seja tão interessante pois geralmente as chaves são usadas como referências para os valores, por isso são nomes ou números. Embora seja interessante pensar que é possível guardar, por exemplo, um &lt;code&gt;Array&lt;/code&gt; como chave para algum outro valor &lt;em&gt;because reasons&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Mas a segunda diferença, &lt;strong&gt;pra mim&lt;/strong&gt;, é a mais importante (leia-se aplicável, prática): ele guarda a ordem dos pares, ou seja, assim é possível por exemplo realizar um loop num &lt;code&gt;Map&lt;/code&gt; e confiar que a ordem da iteração será igual ao objeto internamente! O que não acontece com &lt;code&gt;Object&lt;/code&gt;, onde geralmente você percorreria cada propriedade do próprio objeto e armazenaria num novo &lt;code&gt;Array&lt;/code&gt;, ou algo do tipo dependendo do que deseja.&lt;/p&gt;
&lt;p&gt;A forma de manipulação muda bastante também. Por exemplo, não é possível adicionar ou definir novos pares com a notação &lt;code&gt;.key = value&lt;/code&gt;/&lt;code&gt;[key] = value&lt;/code&gt;, e pegar novos valores só chamando &lt;code&gt;.key&lt;/code&gt;/&lt;code&gt;[key]&lt;/code&gt;, ao invés disso deve-se usar os métodos &lt;code&gt;.set&lt;/code&gt; e &lt;code&gt;.get&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Aqui criamos um objeto &lt;code&gt;Map&lt;/code&gt; através do construtor &lt;code&gt;new&lt;/code&gt;, setamos duas propriedades e mostramos o objeto recém-criado:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Novo Map criado" src="https://dunderlabs.github.io/images/posts/map-e-set-objetos-que-voce-deve-conhecer-em-javascript/new-map.png" /&gt;&lt;/p&gt;
&lt;p&gt;Por ter a ordem de inserção preservada, poderíamos percorrê-lo por alguma das estruturas &lt;code&gt;for&lt;/code&gt;, mas os objeto &lt;code&gt;Map&lt;/code&gt; já tem o método &lt;code&gt;forEach&lt;/code&gt;, com funcionamento quase igual aos objetos &lt;code&gt;Array&lt;/code&gt;: recebe uma função (&lt;em&gt;callback&lt;/em&gt;) que recebe dois argumentos, o primeiro sendo o valor da propriedade e o segundo o nome da propriedade (ordem inversa ao callback de &lt;code&gt;Array&lt;/code&gt;s):&lt;/p&gt;
&lt;p&gt;&lt;img alt="Método de iteração forEach em um objeto Map" src="{filename}/images/posts/map-e-set-objetos-que-voce-deve-conhecer-em-javascript/new-foreach.png" /&gt;&lt;/p&gt;
&lt;p&gt;Outras diferençãs legais são o método &lt;code&gt;has&lt;/code&gt; e a propriedade &lt;code&gt;size&lt;/code&gt;! Quem já teve que contar quantas propriedades um &lt;code&gt;Object&lt;/code&gt; tem, sabe como é penoso ter que fazer um loop no objeto, filtrar as propriedades usando &lt;code&gt;.hasOwnProperty()&lt;/code&gt; e adicionar à um contador, ou usar &lt;code&gt;Object.keys(obj).length&lt;/code&gt; pra quem usa ES6. Com o &lt;code&gt;Map&lt;/code&gt; você só tem que acessar a propriedade &lt;code&gt;size&lt;/code&gt; e TAH-DAH, é retornado o tamanho dele ;)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nx"&gt;obj&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nx"&gt;objSize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// ES5 approach&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;prop&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="nx"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;hasOwnProperty&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;prop&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="nx"&gt;objSize&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;objSize&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// ES6 way&lt;/span&gt;
&lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Object&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;length&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Getting Map&amp;#39;s size&lt;/span&gt;
&lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;map&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Quando utilizá-los?&lt;/h3&gt;
&lt;p&gt;Na MDN tem uma &lt;a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Map#Objetos_e_mapas_comparados"&gt;excelente lista&lt;/a&gt; de como identificar quando utilizar &lt;code&gt;Map&lt;/code&gt; ao invés de &lt;code&gt;Object&lt;/code&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;As keys são desconhecidas até o tempo de execução, você precisa procurá-las dinamicamente?&lt;/li&gt;
&lt;li&gt;Todos os valores sempre serão do mesmo tipo, e podem ser usados de forma intercambiável?&lt;/li&gt;
&lt;li&gt;Você precisa de keys que não são strings?&lt;/li&gt;
&lt;li&gt;Os pares key-value são adicionados ou removidos frequentemente?&lt;/li&gt;
&lt;li&gt;Você tem uma quantidade de pares key-value arbitrária (de troca fácil) ?
A coleção é iterada?&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="https://jsperf.com/map-vs-object-as-hashes/2"&gt;Alguns&lt;/a&gt; &lt;a href="https://jsperf.com/es6-map-vs-object-properties/2"&gt;testes&lt;/a&gt; de performance apresentam diferenças entre as diversas formas de percorrer &lt;code&gt;Map&lt;/code&gt;s e &lt;code&gt;Object&lt;/code&gt;s. Então, be wise ao usá-los.&lt;/p&gt;
&lt;h2&gt;Set&lt;/h2&gt;
&lt;p&gt;Outro objeto bastante interessante é o &lt;code&gt;Set&lt;/code&gt;, muito parecido com o nosso velho conhecido &lt;code&gt;Array&lt;/code&gt;. Se &lt;code&gt;Map&lt;/code&gt; está para &lt;code&gt;Object&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt; está para &lt;code&gt;Array&lt;/code&gt; :D&lt;/p&gt;
&lt;p&gt;A principal diferença conceitual entre objetos do tipo &lt;code&gt;Set&lt;/code&gt; e arrays é que &lt;code&gt;Set&lt;/code&gt; não aceita valores repetidos, ou seja, guarda &lt;strong&gt;somente somente valores únicos&lt;/strong&gt;. Isso pode oferecer mais segurança no código.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Set&lt;/code&gt; tem métodos de manipulação parecidos com &lt;code&gt;Map&lt;/code&gt;: &lt;code&gt;add()&lt;/code&gt; para adicionar novos itens, &lt;code&gt;delete()&lt;/code&gt; para retirar o item (através do item, não do índice), &lt;code&gt;has()&lt;/code&gt; pra verificar se o item existe, &lt;code&gt;forEach()&lt;/code&gt; pra percorrê-lo, e &lt;a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Set"&gt;muitos outros&lt;/a&gt;. A propriedade &lt;code&gt;size&lt;/code&gt; também está presente retornando o tamanho.&lt;/p&gt;
&lt;p&gt;É possível também facilmente criar um &lt;code&gt;Set&lt;/code&gt; a partir de um Array passando ele dentro do construtor com &lt;code&gt;new&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Set sendo criado a partir de um Array" src="https://dunderlabs.github.io/images/posts/map-e-set-objetos-que-voce-deve-conhecer-em-javascript/new-set.png" /&gt;&lt;/p&gt;
&lt;p&gt;O interessante desse exemplo é como ele trata os valores repetidos: ele simplesmente pula as repetições e as desconsidera ;)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;O interessante desses dois tipos de objetos é que eles são como &lt;code&gt;Object&lt;/code&gt; e &lt;code&gt;Array&lt;/code&gt; porém ~ tunados ~ permitindo que se faça muita coisa facilmente, sem precisar brigar com a linguagem pra conseguir resolver o seu problema :D&lt;/p&gt;
&lt;p&gt;Só fique atento com a compatibilidade! Eles vieram junto com o ES6, e caso você não esteja usando algum polyfill como o &lt;a href="https://babeljs.io/learn-es2015/#ecmascript-2015-features-map-set-weak-map-weak-set"&gt;Babel&lt;/a&gt; &lt;code&gt;babel-polyfill&lt;/code&gt; tem que verificar se os ambientes onde esse código vai rodar os suportam.&lt;/p&gt;
&lt;p&gt;Recomendo também conhecer os objetos "irmãos" desses, o &lt;code&gt;WeakMap&lt;/code&gt; e o &lt;code&gt;WeakSet&lt;/code&gt;, que são chamados &lt;em&gt;fracos&lt;/em&gt; porque seus objetos internos podem ser coletados caso o &lt;em&gt;garbage collector&lt;/em&gt; da &lt;em&gt;engine&lt;/em&gt; decida que suas referências devem ser removidas. Talvez por isso eles não tenham tanto valor prático se você não estiver construindo uma grande aplicação ou digamos uma biblioteca, ou algo que exija bastante otimização de performance.&lt;/p&gt;
&lt;p&gt;Você já conhecia esses objetos? Já o utlizou alguma vez? Se não, acredita que irá usar num próximo projeto? A melhor parte de escrever, além de aprender bastante pra poder explicar, é o feedback e o contato com a comunidade. Adoraria ouvir algo de vocês &amp;lt;3&lt;/p&gt;
&lt;p&gt;Brigado pela leitura :*&lt;/p&gt;</summary><category term="javascript"></category><category term="es6"></category><category term="map"></category><category term="set"></category><category term="object"></category><category term="array"></category></entry><entry><title>console dos browsers além do .log</title><link href="https://dunderlabs.github.io/console-alem-do-log.html" rel="alternate"></link><updated>2017-03-18T19:52:00-03:00</updated><author><name>Nilton Cesar</name></author><id>tag:dunderlabs.github.io,2017-03-18:console-alem-do-log.html</id><summary type="html">&lt;p&gt;&lt;img alt="Console e seus métodos" src="https://dunderlabs.github.io/images/posts/console-alem-do-log/post-cover.png" /&gt;&lt;/p&gt;
&lt;p&gt;E aí, meus queridos devs, tudo joia com vocês? ;D&lt;/p&gt;
&lt;p&gt;Vou falar de uma das ferramentas mais poderosas pra quem trabalha com JavaScript e no entanto pouco utilizada: o &lt;code&gt;console&lt;/code&gt;. A &lt;a href="https://console.spec.whatwg.org"&gt;especificação&lt;/a&gt; ainda não é consistente entre os maiores browsers do mercado. Todos os exemplos aqui foram testados no Chrome 57.&lt;/p&gt;
&lt;p&gt;Bem, calma. &lt;code&gt;console&lt;/code&gt; na verdade é um objeto JavaScript que tem uma série de métodos, incluindo o mais famoso (e acho que mais usado), &lt;code&gt;.log&lt;/code&gt;. Quem nunca usou um &lt;code&gt;console.log('enter the function')&lt;/code&gt; ou até &lt;code&gt;console.log('dados recebidos:', data)&lt;/code&gt; pra verificar o que ia acontecendo no código? É bastante útil durante o desenvolvimento porque te dá um feedback rápido do que tá acontecendo direto ali, sem precisar de muito esforço pra entender o que tá acontecendo. Disclaimer: &lt;em&gt;não estou dizendo dizendo que isso deve substituir suas rotinas de testes, ou deixar de debugar quando necessário, ou até mesmo deixar de lado seu TDD ou BDD&lt;/em&gt;. &lt;strong&gt;Nada disso&lt;/strong&gt;.&lt;/p&gt;
&lt;h2&gt;Mostrando informações&lt;/h2&gt;
&lt;p&gt;Bom, quem nunca precisou mostrar aqueles dados que pegou via AJAX, ou marcar onde aparece aquele erro? Há formas mais eficientes de mostrar essas informações:&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;console.log()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Clássico. Mostra as informações da forma que elas vêm.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Clássico console.log" src="https://dunderlabs.github.io/images/posts/console-alem-do-log/log.png" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;console.warn()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Mostra as informações como uma mensagem de alerta, destacando as chamadas de função.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Mensagem de alerta" src="https://dunderlabs.github.io/images/posts/console-alem-do-log/warn.png" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;console.error()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Mostra como uma mensagem de erro,  destacando as chamadas de função.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Mensagem de erro" src="https://dunderlabs.github.io/images/posts/console-alem-do-log/error.png" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;console.info()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Mostra as informações de uma maneira com um ícone descritivo de informação, útil para identificar que tipo de mensagem é essa.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Mensagem de informação" src="https://dunderlabs.github.io/images/posts/console-alem-do-log/info.png" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;console.table()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Esse é muito útil para visualização de dados (arrays e propriedades enumeráveis de objetos) pois os mostra em formato tabular.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Todos os dados tabulados" src="https://dunderlabs.github.io/images/posts/console-alem-do-log/table-all-columns.png" /&gt;&lt;/p&gt;
&lt;p&gt;Ainda é posível filtrar as colunas pelo nome!&lt;/p&gt;
&lt;p&gt;&lt;img alt="Dados tabulados filtrados" src="https://dunderlabs.github.io/images/posts/console-alem-do-log/table-filter-column.png" /&gt;&lt;/p&gt;
&lt;p&gt;Nota: os "erros" aqui &lt;strong&gt;não&lt;/strong&gt; param a execução do código.&lt;/p&gt;
&lt;h2&gt;Contando o tempo de execução&lt;/h2&gt;
&lt;p&gt;Legal também é medir quanto tempo leva pra executar um trecho de código, colocando ele entre &lt;code&gt;.time()&lt;/code&gt; e &lt;code&gt;.timeEnd()&lt;/code&gt;. É interessante também passar como argumento um rótulo para aquele contador, pra poder identificá-los quando houver múltiplos contadores.&lt;/p&gt;
&lt;p&gt;&lt;img alt="'Tempo de execução da função'" src="https://dunderlabs.github.io/images/posts/console-alem-do-log/time.png" /&gt;&lt;/p&gt;
&lt;h2&gt;Verificando as execuções&lt;/h2&gt;
&lt;p&gt;Usando &lt;a href="entendendo-ordenacao-de-arrays-em-javascript-sort-of.html#comment-3200924458"&gt;como exemplo um comentário do post anterior&lt;/a&gt; muito bem indicado pelo &lt;a href="https://disqus.com/by/disqus_Bu8QAZBLDU/"&gt;Hector Cardoso&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;sortByReleaseYear&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;objOriginal&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nx"&gt;objTmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;Object&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;assign&lt;/span&gt;&lt;span class="p"&gt;([],&lt;/span&gt; &lt;span class="nx"&gt;objOriginal&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="nx"&gt;objTmp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;releaseYear&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;releaseYear&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;objTmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="Execução das funções" src="https://dunderlabs.github.io/images/posts/console-alem-do-log/trace.png" /&gt;&lt;/p&gt;
&lt;p&gt;essa função retorna um array ordenado pelo ano de lançamento dos álbuns.
É possível verificar o &lt;em&gt;stack trace&lt;/em&gt;, ou seja, a "pilha" de execuções até a função que está sendo chamada. Colocando antes do &lt;code&gt;return&lt;/code&gt; o método &lt;code&gt;console.trace()&lt;/code&gt;, e executando  &lt;code&gt;sortByReleaseYear(beatlesTopFour)&lt;/code&gt;, é possível ver toda a execução que houve até aquele ponto onde o &lt;code&gt;.trace()&lt;/code&gt; está sendo chamado.&lt;/p&gt;
&lt;h2&gt;Juntando tudo&lt;/h2&gt;
&lt;p&gt;Juntando muito do que vimos até aqui podemos analisar a execução do nosso código com muita riqueza de detalhes:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;info&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;original array&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;beatlesTopFour&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;info&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;ordered array&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;sort by release year&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;table&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;sortByReleaseYear&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;beatlesTopFour&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;timeEnd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;sort by release year&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="Alguns métodos aplicados" src="https://dunderlabs.github.io/images/posts/console-alem-do-log/all-together.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Ainda tem muito a ser explorado, como o &lt;code&gt;.dir()&lt;/code&gt; que é útil para visualizar hierarquicamente grandes quantidades de dados (como na capa do post), trabalhar com grupos através dos métodos &lt;code&gt;group&lt;/code&gt;, &lt;code&gt;groupCollapsed&lt;/code&gt; e &lt;code&gt;groupEnd&lt;/code&gt;, fazer marcações em Timeline, inicar um Profiler... muita coisa legal na &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Console"&gt;MDN&lt;/a&gt; pra gente brincar ;D&lt;/p&gt;
&lt;p&gt;Queria deixar duas referências sensacionais, ambas do &lt;a href="https://twitter.com/fdaciuk"&gt;Fernando Daciuk&lt;/a&gt;: uma é sobre &lt;a href="http://blog.da2k.com.br/2015/01/10/debugar-javascript-no-browser"&gt;como debugar JavaScript no browser&lt;/a&gt; e a outra é sobre &lt;a href="http://blog.da2k.com.br/2015/01/08/javascript-medindo-o-tempo-de-suas-instrucoes/"&gt;como usar o &lt;code&gt;.time()&lt;/code&gt; para medir suas instruções&lt;/a&gt; que falei aqui :)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Atenção&lt;/strong&gt;: esses métodos devem ser usados para fornecer feedback ao desenvolvedor, ou seja, se você estiver construindo uma API é interessante em alguns casos você o use. Caso o seu código vá pra produção e não interesse ao usuário essas mensagens, você deve removê-los do código. Recomendo utilizar o ESLint, que entre outras regras de avaliação do seu código, já tem uma &lt;a href="http://eslint.org/docs/rules/no-console"&gt;regra específica&lt;/a&gt; que retira todas as chamadas de &lt;code&gt;console&lt;/code&gt; ;)&lt;/p&gt;
&lt;p&gt;Se faltou alguma coisa e vocês quiserem adicionar mais informações, ou deixar dúvidas, ou trocar alguma ideia sobre isso, o comentário é livre. Sinta-se à vontade, e vamos trocar uma ideia :DD&lt;/p&gt;</summary><category term="javascript"></category><category term="console"></category><category term="browser"></category><category term="log"></category><category term="debug"></category></entry><entry><title>Entendendo ordenação de arrays em JavaScript, sort of.</title><link href="https://dunderlabs.github.io/entendendo-ordenacao-de-arrays-em-javascript-sort-of.html" rel="alternate"></link><updated>2017-03-10T15:15:00-03:00</updated><author><name>Nilton Cesar</name></author><id>tag:dunderlabs.github.io,2017-03-10:entendendo-ordenacao-de-arrays-em-javascript-sort-of.html</id><summary type="html">&lt;p&gt;E aí, meus queridos devs, tudo ok com vocês? :D
Depois de uma conversinha com &lt;a href="https://twitter.com/ericleribertson"&gt;Patrick Mazulo&lt;/a&gt; sobre JavaScript, ele me veio com o seguinte cenário na ordenação de valores de um array:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="nx"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Parece bem simples e direto, porém o resultado é:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1, 10, 2, 3, 4, 5, 6, 7, 8, 9&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="WHAT" src="http://i.giphy.com/EsmlrgWNx5v0Y.gif" title="ÉOQ" /&gt;&lt;/p&gt;
&lt;p&gt;Eu tive exatamente a mesma reação na primeira vez que  vi isso.&lt;/p&gt;
&lt;p&gt;Na verdade, o que acontece ali é que o método &lt;code&gt;.sort()&lt;/code&gt; ordena em ordem crescente através do caracteres da tabela Unicode quando convertidos para string. Então nesse caso, "10" vem antes do "2" porque "1", que é o primeiro caractere de "10", vem antes do "2".&lt;/p&gt;
&lt;p&gt;De acordo com a implementação da &lt;a href="http://unicode.org/charts/"&gt;tabela Unicode&lt;/a&gt;, &lt;a href="http://unicode.org/charts/PDF/U0000.pdf"&gt;é possível perceber, pelo menos no nosso subset&lt;/a&gt;, que a ordem é: alguns símbolos, números, letras maiúsculas, letras minúsculas, mais alguns outros símbolos. O que quer dizer que deverão também obedecer a essa ordem, ou seja, "a" antes do "b", "ab" depois do "a" e antes de "b", "a0" entre "a" e "ab", "Ab" antes de "a", e por aí vai.&lt;/p&gt;
&lt;h2&gt;"mas como eu ordeno números pelo valor"?&lt;/h2&gt;
&lt;p&gt;Mas voltando ao nosso problema inicial, o objetivo era ordenar os números pelo seu valor, não pelo ~código Unicode, certo?&lt;/p&gt;
&lt;p&gt;Bom, pra isso o JavaScript aceita um parâmetro opcional no método &lt;code&gt;sort&lt;/code&gt;: uma função que determina como seriam as regras da ordenação. Essa função recebe dois argumentos, por convenção chamados de &lt;strong&gt;a&lt;/strong&gt; e &lt;strong&gt;b&lt;/strong&gt;, que representam dois itens do array que estão sendo comparados.&lt;/p&gt;
&lt;p&gt;&lt;img alt="hm" src="https://media.giphy.com/media/sBl8Fowq0ErFC/giphy.gif" /&gt;&lt;/p&gt;
&lt;p&gt;A vantagem disso é que, na função, você tem controle de qual critério da ordenação utilizar, de acordo com algumas regras.&lt;/p&gt;
&lt;p&gt;Funciona assim: são comparados &lt;code&gt;a&lt;/code&gt; e &lt;code&gt;b&lt;/code&gt;, e caso:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;a comparação seja menor que zero, &lt;code&gt;a&lt;/code&gt; é posicionado antes de &lt;code&gt;b&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a comparação seja maior que zero, &lt;code&gt;a&lt;/code&gt; é posicionado depois de &lt;code&gt;b&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a comparação seja igual a zero, &lt;code&gt;a&lt;/code&gt; e &lt;code&gt;b&lt;/code&gt; permancem com as posições inalteradas&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;"Bom, mas como comparar? Não entendi como essas regras se aplicam"&lt;/p&gt;
&lt;h3&gt;explicação curta (pois deadline chegando)&lt;/h3&gt;
&lt;p&gt;O que você pode fazer é diminuir os dois valores entre si, e o resultado vai decidir se &lt;code&gt;a&lt;/code&gt; ou &lt;code&gt;b&lt;/code&gt; avança, recua, ou ambos permanecem nas posições atuais.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;arr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Array original:&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="nx"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;

&lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Array ordenado:&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;O código acima define um array, o ordena, e o mostra modificado. A parte-chave desse código é o &lt;code&gt;a - b&lt;/code&gt; que faz o array ser ordenado de forma &lt;strong&gt;crescente&lt;/strong&gt;. O contrário, &lt;code&gt;b - a&lt;/code&gt; o ordena de forma &lt;strong&gt;decrescente&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="wow" src="http://i.giphy.com/vLq5FWMjfN47S.gif" /&gt;&lt;/p&gt;
&lt;h3&gt;aprofundando a explicação (para nerds)&lt;/h3&gt;
&lt;p&gt;O que acontece é que o &lt;code&gt;sort()&lt;/code&gt; pega o array original, compara dois valores e os &lt;strong&gt;muda de posição de acordo com essa comparação&lt;/strong&gt;, logo em seguida ele pega novamente dois valores e os compara pra &lt;strong&gt;rearranjá-los de novo&lt;/strong&gt;, e faz isso até que todo o array esteja ordenado.&lt;/p&gt;
&lt;p&gt;Pegando o primeiro exemplo, onde usamos &lt;code&gt;a - b&lt;/code&gt;, a ordenação acontece da seguinte forma: se o primeiro elemento comparado, no caso &lt;code&gt;a&lt;/code&gt;, for maior que &lt;code&gt;b&lt;/code&gt;, a subtração &lt;code&gt;a - b&lt;/code&gt; resulta em um valor maior que zero, então &lt;code&gt;a&lt;/code&gt; é posicionado depois de &lt;code&gt;b&lt;/code&gt; (de acordo com as regras). Essa mesma lógica aplicada repetidamente no array, que está sendo modificado, faz que com que os valores maiores sejam posicionados mais ao fim do array, ou seja, faz a ordenação em ordem crescente!&lt;/p&gt;
&lt;p&gt;A mesma lógica se aplica para ordenação decrescente, &lt;code&gt;b - a&lt;/code&gt;, só que agora com os valores trocados de lugar faz com que a ordenação seja ao contrário da anterior :). Se você ficou confuso ou quer ver isso passo-a-passo, você pode visualizar os valores de &lt;code&gt;a&lt;/code&gt; e &lt;code&gt;b&lt;/code&gt; mudando:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="mindblowing" src="https://media.tenor.co/images/c7eac59fb909510e714e85de277ca81a/raw" /&gt;&lt;/p&gt;
&lt;p&gt;Não encontrei na &lt;a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf"&gt;especificação&lt;/a&gt;, mas você pode observar que a lógica por trás disso é semelhante a alguns algoritmos de ordenação conhecidos, como o BubbleSort. &lt;a href="https://blog.rodneyrehm.de/archives/14-sorting-were-doing-it-wrong.html"&gt;Aparentemente, cada engine implementa esse algoritmo de uma maneira&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Indo um pouco além&lt;/h2&gt;
&lt;p&gt;Já que &lt;code&gt;a&lt;/code&gt; e &lt;code&gt;b&lt;/code&gt; são, de fato, elementos do array, é possível acessá-los e expandir um pouco as possiblidades do uso do método &lt;code&gt;sort&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Digamos que você tenha um array de objetos com o nome de um álbum e o ano de lançamento em cada um:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;beatlesTopFour&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;album&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Abbey Road&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;releaseYear&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1969&lt;/span&gt;
    &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;album&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Revolver&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;releaseYear&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1966&lt;/span&gt;
    &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;album&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;The Beatles (White Album)&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;releaseYear&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1968&lt;/span&gt;
    &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;album&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Rubber Soul&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;releaseYear&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1965&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Pra ordenar esses objetos de acordo com o ano de lançamento, você pode comparar a propriedade &lt;code&gt;releaseYear&lt;/code&gt; de cada objeto, sem ter que manipular mais nada :)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;beatlesTopFour&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;releaseYear&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;releaseYear&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;e TCHARAM: ordenados em ordem crescente pelo ano&lt;/p&gt;
&lt;p&gt;&lt;img alt="awesome" src="https://media.giphy.com/media/aLdiZJmmx4OVW/giphy.gif" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Pro-tip&lt;/strong&gt;: fique atento com a utilização do método &lt;code&gt;sort&lt;/code&gt; pois ele altera o array original. Se você está aplicando uma abordagem funcional, pode não ser interessante utilizá-lo em escopos mais externos.&lt;/p&gt;
&lt;p&gt;Espero que esse artigo tenha sido útil, e não deixem de olhar o que tem na &lt;a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Array/sort"&gt;MDN&lt;/a&gt;, por exemplo, caso algo não tenha ficado claro. OU é só gritar aqui embaixo que a gente responde ;)&lt;/p&gt;
&lt;p&gt;Sempre disponível praquele feedback maroto de vocês. Até logo!&lt;/p&gt;</summary><category term="javascript"></category><category term="array"></category><category term="sort"></category><category term="number"></category><category term="ordering"></category></entry><entry><title>this or: How I Learned to Stop Worrying and Love JavaScript</title><link href="https://dunderlabs.github.io/this-or-how-i-learned-to-stop-worrying-and-love-javascript.html" rel="alternate"></link><updated>2017-03-03T15:00:00-03:00</updated><author><name>Nilton Cesar</name></author><id>tag:dunderlabs.github.io,2017-03-03:this-or-how-i-learned-to-stop-worrying-and-love-javascript.html</id><summary type="html">&lt;p&gt;Vou tentar fazer uma rápida porém merecida explicação sobre o uso do &lt;code&gt;this&lt;/code&gt; na execução de funções, tópico que tira a paciência de muita gente que tá começando na linguagem ou vem ~viciado de libs e frameworks.
Os exemplos aqui são executados no browser, mas podem ser executados no Node sem problema algum, mudando só o objeto &lt;code&gt;window&lt;/code&gt; para &lt;code&gt;global&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;O que é &lt;em&gt;isto&lt;/em&gt;?&lt;/h2&gt;
&lt;p&gt;Bom, você deve tentar adivinhar pela tradução que &lt;code&gt;this&lt;/code&gt; se refere a "isto". Não está totalmente errado, o ponto chave é o que é o "isto". Tente executar o &lt;code&gt;this&lt;/code&gt; no console, só ele e nada mais, e você vai receber o objeto &lt;code&gt;window&lt;/code&gt;. Esses são os objetos que, nos seus ambientes, guardam as referências pros outros objetos, funções, classes, etc, definidos pelo desenvolvedor. Ou seja, quando você define e atribui &lt;code&gt;var a = 7&lt;/code&gt; fora de escopo de funções ou fora de objetos, na verdade é criada uma referência para essa variável em &lt;code&gt;window&lt;/code&gt;, significando que dá pra acessar essa mesma variável tanto fazendo &lt;code&gt;a&lt;/code&gt; como &lt;code&gt;window.a&lt;/code&gt;.
Ok, mas e se eu definir uma função assim&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;outerScope&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;quando eu chamá-la eu vou rebecer a própria função? (??) Não.&lt;/p&gt;
&lt;p&gt;Quando você chama &lt;code&gt;outerScope()&lt;/code&gt; na verdade é a mesma coisa de estar chamando &lt;code&gt;window.outerScope()&lt;/code&gt; e o &lt;code&gt;this&lt;/code&gt; vai mostrar &lt;code&gt;window&lt;/code&gt;. O que acontece é que o &lt;code&gt;this&lt;/code&gt; se refere justamente ao contexto de invocação, ou seja, como e onde ela é &lt;em&gt;chamada&lt;/em&gt;. No exemplo, quem está chamando a função &lt;code&gt;outerScope&lt;/code&gt; implicitamente é o objeto &lt;code&gt;window&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;this&lt;/code&gt; em métodos&lt;/h2&gt;
&lt;p&gt;Ainda no mesmo ambiente, suponha que você agora defina um objeto &lt;code&gt;o&lt;/code&gt; assim:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;o&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;m&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;outerScope&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;A chave &lt;code&gt;m&lt;/code&gt; tem como valor a função definida anteriormente, o que faz com que &lt;code&gt;m&lt;/code&gt; seja um método do objeto &lt;code&gt;o&lt;/code&gt;. Pra executar, basta &lt;code&gt;o.m()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;TCHARAN! O que foi mostrado foi o próprio objeto &lt;code&gt;o&lt;/code&gt;, porque agora ele é quem executa essa função que agora foi atribuída a ele.&lt;/p&gt;
&lt;p&gt;Percebe como nesse caso, mesmo a função sendo definida fora do objeto, quando é atribuída e trazida pra dentro do objeto,e a partir daí não tem mais relação com o que acontece externamente com a função, o &lt;code&gt;this&lt;/code&gt; muda? ;)&lt;/p&gt;
&lt;p&gt;O mesmo comportamento acontece se tratando de eventos:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;el&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;document&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;querySelector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;#submit-form&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="nx"&gt;el&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;addEventListener&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;click&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;No código acima, atribuímos um elemento HTML à variável &lt;code&gt;el&lt;/code&gt;, e depois definimos que o evento de click executa uma função que loga o &lt;code&gt;this&lt;/code&gt;. Nesse caso, também o &lt;code&gt;this&lt;/code&gt; se refere ao próprio elemento que disparou o evento, no caso &lt;code&gt;el&lt;/code&gt;.
Até agora imagino que tá tudo de boa, eu acho.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;function&lt;/code&gt;s criam escopo, e não preservam o &lt;code&gt;this&lt;/code&gt; do contexto&lt;/h2&gt;
&lt;p&gt;Voltemos ao exemplo do objeto, mas vamos criar mais um método:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;o&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;m&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;outerScope&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;inside&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;};&lt;/span&gt;

        &lt;span class="nx"&gt;inside&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Aqui, adicionamos mais um método à &lt;code&gt;o&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt;, que loga o &lt;code&gt;this&lt;/code&gt; duas vezes: uma diretamente no método e outra dentro de uma função que está &lt;em&gt;dentro&lt;/em&gt; desse método. Se você executar &lt;code&gt;o.n()&lt;/code&gt;, sua reação pode ser das mais variadas: "whatta fuck" "Q" "BÉ ISSO, MAH" e por aí vai.&lt;/p&gt;
&lt;p&gt;O primeiro &lt;code&gt;this&lt;/code&gt; se refere ao objeto &lt;code&gt;o&lt;/code&gt;, como anteriormente, porém sendo chamado dentro da função &lt;code&gt;inside&lt;/code&gt; ele mostra &lt;code&gt;window&lt;/code&gt;! Isso acontece porque, ao criar uma nova função com &lt;code&gt;function&lt;/code&gt;, o &lt;code&gt;this&lt;/code&gt; (e até &lt;code&gt;arguments&lt;/code&gt;) não é trazido do contexto da função mais externa para o função interna, e então ele se refere ao próprio &lt;code&gt;window&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="mindblowing" src="https://media.giphy.com/media/OK27wINdQS5YQ/giphy.gif" title="mindblowing" /&gt;&lt;/p&gt;
&lt;p&gt;Mas então, como diabos eu acessaria o &lt;code&gt;this&lt;/code&gt; da função externa? Quando eu tiver definindo uma função construtora e seus metódos, como é que eu ia referenciar o &lt;code&gt;this&lt;/code&gt;, que é o objeto criado?&lt;/p&gt;
&lt;h3&gt;1/2: arrow function&lt;/h3&gt;
&lt;p&gt;Se você é descolado(a) e quer usar as novas features da linguagem e dizer que tá por dentro, pode usar as queridinhas arrow functions. Mais do que uma forma curta de escrever funções anônimas (&lt;code&gt;() =&amp;gt; console.log(this)&lt;/code&gt;), as arrow functions fazem o contexto permanecer o mesmo para o &lt;code&gt;this&lt;/code&gt;, ficando o código assim&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;o&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;m&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;outerScope&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="c1"&gt;// Tenho que autoexecutá-la já que é uma função anônima&lt;/span&gt;
        &lt;span class="p"&gt;(()&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;})();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;e mostrando duas vezes o objeto &lt;code&gt;o&lt;/code&gt;. Simples e elegante.&lt;/p&gt;
&lt;h2&gt;2/2: "that" pra quem te quer&lt;/h2&gt;
&lt;p&gt;Se você não quer usar arrow function, ou melhor, quando NÃO HAVIA ISSO NA LINGUAGEM, o que era feito era atribuir o valor de &lt;code&gt;this&lt;/code&gt; a outra variável no escopo acima, geralmente com o nome "that" ou "self" e aí sim através dela estaria disponível no escopo mais interno. Ficaria assim:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;o&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;m&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;outerScope&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="c1"&gt;// TAH-DAH ;)&lt;/span&gt;
        &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;that&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;inside&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;that&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;};&lt;/span&gt;

        &lt;span class="nx"&gt;inside&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Conclusão&lt;/h2&gt;
&lt;p&gt;Acho que consegui cobrir os principais casos do &lt;code&gt;this&lt;/code&gt; na invocação de funções. Se faltou alguma coisa (e faltou), comenta aí embaixo pra gente trocar uma ideia sobre :D
Pra um texto bem mais aprofundado e completo, recomendo demais a leitura do EXCELENTE &lt;a href="https://github.com/getify/You-Dont-Know-JS/tree/master/this%20%26%20object%20prototypes"&gt;You Don't Know JS: &lt;em&gt;this&lt;/em&gt; &amp;amp; Object Prototypes&lt;/a&gt;, especialmente os capitulos 1 e 2 tratam desse tema.&lt;/p&gt;
&lt;p&gt;Durante muito tempo eu &lt;em&gt;só&lt;/em&gt; usei jQuery nas minhas páginas, pelos motivos óbvios: mais rapidez no desenvolvimento, segurança ao fazer uma página que vai funcionar na maior quantidade de navegadores possível, biblioteca que faz de tudo um pouco, etc. E longe de mim condenar a lib, eu acho que o que merece atenção é a &lt;em&gt;atitude&lt;/em&gt; dos desenvolvedores que a utilizam sem conhecer a linguagem em si, porque você acaba ficando viciado nela sem realmente entender como a liguagem funciona e não  sabe o que fazer quando você não tem ela à mão. Recomendo botar a mão na massa.&lt;/p&gt;</summary><category term="javascript"></category><category term="lexical scope"></category><category term="dynamic scope"></category><category term="arrow function"></category></entry></feed>