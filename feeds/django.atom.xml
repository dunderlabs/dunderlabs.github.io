<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>__labs__</title><link href="https://dunderlabs.github.io/" rel="alternate"></link><link href="https://dunderlabs.github.io/feeds/django.atom.xml" rel="self"></link><id>https://dunderlabs.github.io/</id><updated>2017-07-27T19:21:00-03:00</updated><entry><title>Django startproject: Iniciando o seu projeto</title><link href="https://dunderlabs.github.io/django-iniciando-seu-projeto.html" rel="alternate"></link><updated>2017-07-27T19:21:00-03:00</updated><author><name>Patrick Mazulo</name></author><id>tag:dunderlabs.github.io,2017-07-27:django-iniciando-seu-projeto.html</id><summary type="html">&lt;p&gt;&lt;img alt="Créditos da imagem" src="https://dunderlabs.github.io/images/posts/django-startproject.png" /&gt;&lt;/p&gt;
&lt;p&gt;Fala pessoal, tudo beleza? Como prometido, vamos dar prosseguimento nesta série de posts. Agora que já temos o nosso boilerplate, vamos poder iniciar nosso projeto. Antes de tudo, você precisa ter configurado o seu ambiente de desenvolvimento. Se você não tiver feito isso ainda e/ou não souber muito sobre esse tema, aqui na casa temos &lt;a href="https://dunderlabs.github.io/criando-seu-ambiente-para-desenvolvimento-web-com-django.html"&gt;outro post&lt;/a&gt; onde você vai poder tirar suas dúvidas sobre o assunto :)&lt;/p&gt;
&lt;p&gt;Sem mais delongas, vou criar o meu ambiente virtual para o projeto usando o virtualenvwrapper. O output vai ser algo muito parecido com:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;mkvirtualenv turbo_send_mail
Using base prefix &lt;span class="s1"&gt;&amp;#39;/usr&amp;#39;&lt;/span&gt;
New python executable in /home/mazulo/.virtualenvs/turbo_send_mail/bin/python
Installing setuptools, pip, wheel...done.
virtualenvwrapper.user_scripts creating /home/mazulo/.virtualenvs/turbo_send_mail/bin/predeactivate
virtualenvwrapper.user_scripts creating /home/mazulo/.virtualenvs/turbo_send_mail/bin/postdeactivate
virtualenvwrapper.user_scripts creating /home/mazulo/.virtualenvs/turbo_send_mail/bin/preactivate
virtualenvwrapper.user_scripts creating /home/mazulo/.virtualenvs/turbo_send_mail/bin/postactivate
virtualenvwrapper.user_scripts creating /home/mazulo/.virtualenvs/turbo_send_mail/bin/get_env_details
Error: deactivate must be sourced. Run &lt;span class="s1"&gt;&amp;#39;source deactivate&amp;#39;&lt;/span&gt;
instead of &lt;span class="s1"&gt;&amp;#39;deactivate&amp;#39;&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Feito isso, vamos instalar o Django para que possamos utilizar o &lt;code&gt;django-admin&lt;/code&gt;. Basta um comando do &lt;code&gt;pip&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;pip install django
Collecting django
  Downloading Django-1.11.3-py2.py3-none-any.whl &lt;span class="o"&gt;(&lt;/span&gt;6.9MB&lt;span class="o"&gt;)&lt;/span&gt;
    100% &lt;span class="p"&gt;|&lt;/span&gt;████████████████████████████████&lt;span class="p"&gt;|&lt;/span&gt; 7.0MB 131kB/s 
Collecting pytz &lt;span class="o"&gt;(&lt;/span&gt;from django&lt;span class="o"&gt;)&lt;/span&gt;
  Using cached pytz-2017.2-py2.py3-none-any.whl
Installing collected packages: pytz, django
Successfully installed django-1.11.3 pytz-2017.2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Agora vamos usar alguns recursos do &lt;code&gt;django-admin&lt;/code&gt; que podem passar despercebidos. Dentre eles:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--template&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;Aqui você pode especificar um diretório ou uma URL de um template de projeto customizado. No caso de URL, vamos usar a do GitHub que nos dá o nosso projeto comprimido num &lt;code&gt;.zip&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--verbosity&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;Especifica a quantidade de informação que aquele comando vai jogar na tela conforme ele é executado. Os níveis são:&lt;ul&gt;
&lt;li&gt;0 significa sem output&lt;/li&gt;
&lt;li&gt;1 significa output normal (default)&lt;/li&gt;
&lt;li&gt;2 significa output verboso&lt;/li&gt;
&lt;li&gt;3 significa output muito verboso&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vou usar o 3 que é pra termos o máximo de informação de como esse processo ocorre. Ah, como comentei no post anterior, o nosso projeto vai ser um simples sistema que envia e-mails para contatos que eu salvar, como em uma agenda. O nome deste &lt;a href="https://media.giphy.com/media/aBDQ0bQ4b4sx2/giphy.gif"&gt;inovador&lt;/a&gt; projeto será: &lt;em&gt;turbo_send_mail_project&lt;/em&gt;. Nome escolhido, vamos enfim dar o start:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;django-admin startproject turbo_send_mail_project --template&lt;span class="o"&gt;=&lt;/span&gt;https://github.com/dunderlabs/django-boilerplate/archive/master.zip --verbosity 3
Rendering project template files with extensions: .py
Rendering project template files with filenames: 
Downloading https://github.com/dunderlabs/django-boilerplate/archive/master.zip
Extracting /tmp/django_project_template_6nafk1qd_download/django-boilerplate-master.zip
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/runtime.txt
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/requirements.txt
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/package.json
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/manage.py
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/example.env
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/bower.json
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/app.json
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/README.md
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/Procfile
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/Makefile
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/.gitignore
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/.bowerrc
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/settings/static.py
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/settings/security.py
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/settings/mail.py
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/settings/base.py
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/settings/__init__.py
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/requirements/test.txt
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/requirements/test.in
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/requirements/production.txt
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/requirements/production.in
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/requirements/heroku.txt
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/requirements/heroku.in
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/requirements/dev.txt
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/requirements/dev.in
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/frontend/templates/base.html
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/frontend/templates/core/index.html
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/frontend/styles/main.scss
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/bin/post_compile
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/backend/wsgi.py
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/backend/urls.py
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/backend/core/views.py
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/backend/core/utils.py
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/backend/core/urls.py
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/backend/core/tests.py
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/backend/core/models.py
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/backend/core/forms.py
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/backend/core/apps.py
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/backend/core/admin.py
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/backend/core/__init__.py
Creating /home/mazulo/dev/github/dunderlabs/turbo_send_mail_project/backend/core/migrations/__init__.py
Cleaning up temporary files.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como você pode ver, ele faz o download do nosso projeto zipado em &lt;code&gt;/tmp/django_project_template_&amp;lt;hash&amp;gt;_download/&lt;/code&gt;, um diretório que ele criou para extrair os arquivos do &lt;code&gt;.zip&lt;/code&gt; e depois criar o nosso projeto usando esses arquivos dentro do diretório onde eu rodei o comando. Após isso, ele vai limpar os arquivos extraídos naquele diretório temporário criado anteriormente, deixando só o &lt;code&gt;master.zip&lt;/code&gt;. Ao acessar o diretório do projeto que o &lt;code&gt;startproject&lt;/code&gt; criou, você vai notar que a estrutura vai ser extamente a mesma mostrada no post anterior:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;tree -d -L &lt;span class="m"&gt;4&lt;/span&gt;               
.
├── backend
│   └── core
│       └── migrations
├── bin
├── frontend
│   ├── styles
│   └── templates
│       └── core
├── requirements
└── settings
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Finalizada essa parte, os próximos passos serão: atualizar os pacotes nos requirements, instalar eles e por fim instalar as dependências do front. Vou em cada um dos passos.&lt;/p&gt;
&lt;p&gt;Para o &lt;code&gt;make pip-compile&lt;/code&gt; você vai ter uma saída parecida com essa para cada um dos arquivos &lt;code&gt;requirements/*.in&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;make pip-compile 
&lt;span class="c"&gt;# Update requirements/*.txt with latest packages from requirements/*.in&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; Installing/upgrading pip-tools...
pip install -qU pip-tools
&amp;gt;&amp;gt;&amp;gt; Upgrading &lt;span class="nb"&gt;local &lt;/span&gt;packages...
pip-compile -U requirements/dev.in
&lt;span class="c"&gt;#&lt;/span&gt;
&lt;span class="c"&gt;# This file is autogenerated by pip-compile&lt;/span&gt;
&lt;span class="c"&gt;# To update, run:&lt;/span&gt;
&lt;span class="c"&gt;#&lt;/span&gt;
&lt;span class="c"&gt;#    pip-compile --output-file requirements/dev.txt requirements/dev.in&lt;/span&gt;
&lt;span class="c"&gt;#&lt;/span&gt;
&lt;span class="nv"&gt;click&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;6.7                &lt;span class="c"&gt;# via python-dotenv&lt;/span&gt;
dj-database-url&lt;span class="o"&gt;==&lt;/span&gt;0.4.2
django-appconf&lt;span class="o"&gt;==&lt;/span&gt;1.0.2     &lt;span class="c"&gt;# via django-compressor&lt;/span&gt;
django-compressor&lt;span class="o"&gt;==&lt;/span&gt;2.1.1
&lt;span class="nv"&gt;django&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;1.11.3
&lt;span class="o"&gt;[&lt;/span&gt;mais...&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Após essa atualização, só nos resta instalar usando o comando &lt;code&gt;make install-dev-requirements&lt;/code&gt;, que vai nos dar um output semelhante a esse:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;make install-dev-requirements 
&lt;span class="c"&gt;# Install requirements for a local development environment&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; Installing dev requirements...
pip install -qU pip-tools
pip-sync requirements/*.txt
Collecting dj-database-url&lt;span class="o"&gt;==&lt;/span&gt;0.4.2
  Using cached dj_database_url-0.4.2-py2.py3-none-any.whl
Collecting django-appconf&lt;span class="o"&gt;==&lt;/span&gt;1.0.2
  Using cached django_appconf-1.0.2-py2.py3-none-any.whl
Collecting django-compressor&lt;span class="o"&gt;==&lt;/span&gt;2.1.1
&lt;span class="o"&gt;[&lt;/span&gt;mais...&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Agora só ficou faltando as dependências do front. Mas antes de rodar o comando, certifique-se que você tem o &lt;a href="https://bower.io/"&gt;bower&lt;/a&gt; instalado. Caso contrário, na página oficial você vai encontrar um guia de como instalar, de acordo com o seu sistema operacional. Feito isso, execute o comando &lt;code&gt;make setup-frontend&lt;/code&gt;, que vai gerar um output como esse:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;make setup-frontend 
bower install --allow-root
bower semantic#^2.2.4           cached https://github.com/Semantic-Org/Semantic-UI.git#2.2.10
bower semantic#^2.2.4         validate 2.2.10 against https://github.com/Semantic-Org/Semantic-UI.git#^2.2.4
bower susy#^2.2.12              cached https://github.com/ericam/susy.git#2.2.12
bower susy#^2.2.12            validate 2.2.12 against https://github.com/ericam/susy.git#^2.2.12
bower jquery#^3.1.0             cached https://github.com/jquery/jquery-dist.git#3.2.1
bower jquery#^3.1.0           validate 3.2.1 against https://github.com/jquery/jquery-dist.git#^3.1.0
&lt;span class="o"&gt;[&lt;/span&gt;mais...&lt;span class="o"&gt;]&lt;/span&gt;
susy#2.2.12 frontend/bower_components/susy

jquery#3.2.1 frontend/bower_components/jquery

semantic#2.2.11 frontend/bower_components/semantic
└── jquery#3.2.1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Agora estamos prontos!&lt;/strong&gt; Para testar nossa aplicação, vamos rodar o famoso &lt;code&gt;runserver&lt;/code&gt;. Ao executar esse comando, você verá uma saída como a debaixo, mas já avisando: não se preocupe com a mensagem que vai estar em vermelhos sobre &lt;em&gt;15 unapplied migrations&lt;/em&gt; por enquanto. A saída vai ser algo assim:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;python manage.py runserver 8001
Performing system checks...

System check identified no issues &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; silenced&lt;span class="o"&gt;)&lt;/span&gt;.

You have &lt;span class="m"&gt;15&lt;/span&gt; unapplied migration&lt;span class="o"&gt;(&lt;/span&gt;s&lt;span class="o"&gt;)&lt;/span&gt;. Your project may not work properly &lt;span class="k"&gt;until&lt;/span&gt; you apply the migrations &lt;span class="k"&gt;for&lt;/span&gt; app&lt;span class="o"&gt;(&lt;/span&gt;s&lt;span class="o"&gt;)&lt;/span&gt;: admin, auth, contenttypes, sessions, sites.
Run &lt;span class="s1"&gt;&amp;#39;python manage.py migrate&amp;#39;&lt;/span&gt; to apply them.

July 27, &lt;span class="m"&gt;2017&lt;/span&gt; - 21:23:45
Django version 1.11.3, using settings &lt;span class="s1"&gt;&amp;#39;settings&amp;#39;&lt;/span&gt;
Starting development server at http://127.0.0.1:8001/
Quit the server with CONTROL-C.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ao acessar &lt;a href="http://localhost:8001/"&gt;http://localhost:8001/&lt;/a&gt; você verá uma página quase em branco. "Quase" porque se você abrir o arquivo &lt;code&gt;frontend/styles/main.scss&lt;/code&gt; vai ver que o &lt;code&gt;body&lt;/code&gt; vai estar com &lt;code&gt;background: #eee;&lt;/code&gt;. O que significa que o carregamento dos arquivos estáticos, bem como o compilador e "compressor" de arquivos (ou seja, o django-compreesor) está funcionando muito bem. Bom, sobre eles eu vou falar em outro post, porque esse acaba por aqui ;)&lt;/p&gt;
&lt;p&gt;No próximo post vamos começar a programar de verdade, com uns leves toques de testes automatizados. Fiquem ligados!&lt;/p&gt;
&lt;p&gt;Dúvidas e/ou críticas, só visitar os comentários mais abaixo. Valeu pessoal, e até a próxima!&lt;/p&gt;
&lt;p&gt;&lt;br&gt;
Referências:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Documentação sobre o &lt;a href="https://docs.djangoproject.com/en/1.11/ref/django-admin/"&gt;django-admin&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="django"></category><category term="django-serie"></category></entry><entry><title>Django Boilerplate: A estrutura de projeto Django que tenho usado</title><link href="https://dunderlabs.github.io/django-boilerplate-a-estrutura-de-projeto-django-que-tenho-usado.html" rel="alternate"></link><updated>2017-07-27T01:11:00-03:00</updated><author><name>Patrick Mazulo</name></author><id>tag:dunderlabs.github.io,2017-07-27:django-boilerplate-a-estrutura-de-projeto-django-que-tenho-usado.html</id><summary type="html">&lt;p&gt;&lt;img alt="Créditos da imagem" src="https://dunderlabs.github.io/images/posts/django-boilerplate.png" /&gt;&lt;/p&gt;
&lt;h1&gt;Django Boilerplate: A estrutura de projeto Django que tenho usado&lt;/h1&gt;
&lt;p&gt;Fala pessoal, tudo beleza? Finalmente eu &lt;s&gt;criei vergonha na cara&lt;/s&gt; vou iniciar uma série de posts sobre Django. YAY!&lt;/p&gt;
&lt;p&gt;Vou falar sobre alguns quesitos interessantes e que a galera lá do grupo &lt;a href="https://t.me/djangobrasil"&gt;Django Brasil&lt;/a&gt; no Telegram pediram. Inclusive fica aí a deixa pra você participar do grupo, caso ainda não conheça :)&lt;/p&gt;
&lt;p&gt;Antes de tudo, achei interessante começar falando sobre a estrutura de projeto. Nós já conhecemos o bom e velho &lt;code&gt;django-admin.py startproject myproject&lt;/code&gt;, que vai nos gerar uma estrutura parecida com essa:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;.
└── myproject
    ├── manage.py
    └── myproject
        ├── __init__.py
        ├── settings.py
        ├── urls.py
        └── wsgi.py

&lt;span class="m"&gt;2&lt;/span&gt; directories, &lt;span class="m"&gt;6&lt;/span&gt; files
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Depois de algum tempo, você começa a se aventurar em querer testar outras estruturas que possam melhorar a sua produtividade, modularidade, segurança e outros pontos do seu projeto. Um ótimo guia que você pode adquirir, é o livro &lt;a href="https://www.twoscoopspress.com/products/two-scoops-of-django-1-11"&gt;Two Scoops of Django&lt;/a&gt; que recentemente foi atualizado para a versão 1.11 (LTS) do Django. Outra maneira é pesquisar outras estruturas por aí. GitHub é uma ótima fonte, lá cê encontra &lt;strong&gt;várias&lt;/strong&gt; opções. Daí uma ótima ideia é: ver cada um, estudar seu esqueleto, a abordagem pretendida, e se ela se encaixa bem nas suas necessidades/requisitos. Feito isso, você pode:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Adotar um desses boilerplates&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pegar o que viu de melhor nos pesquisados e fazer o seu&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Há um tempo atrás, eu e 2 amigos trabalhávamos numa certa empresa. Num dado momento resolvemos mudar a maneira como iniciaríamos os novos projetos. Um desses caras havia feito uma estrutura diferente em um projeto pessoal. A partir daí, resolvemos ir lapidando até chegarmos no que tornou-se nossa estrutura "oficial". A estrutura final é aquela da imagem no início do post, e que repito aqui abaixo (save your scroll):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;.
├── backend
│   └── core
│       └── migrations
├── bin
├── frontend
│   ├── bower_components
│   │   ├── jquery
│   │   ├── semantic
│   │   └── susy
│   ├── scripts
│   ├── styles
│   └── templates
│       └── core
├── requirements
└── settings
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como vocês podem ver, separamos tudo em módulos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;backend&lt;ul&gt;
&lt;li&gt;Irá conter tudo diretamente relacionado ao backend, e com isso teremos: os módulos das apps, bem como o arquivo &lt;code&gt;urls.py&lt;/code&gt; principal e o &lt;code&gt;wsgi.py&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;frontend&lt;ul&gt;
&lt;li&gt;Tudo relacionado ao frontend estará neste diretório, ou seja, isso inclui os arquivos de template e os arquivos estáticos.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;requirements&lt;ul&gt;
&lt;li&gt;Estaremos utilizando o &lt;a href="https://github.com/jazzband/pip-tools"&gt;pip-tools&lt;/a&gt; que é uma ferramenta sensacional para ajudar a manter as versões dos seus pacotes sempre atualizadas e pinadas. Aqui você pode ler um &lt;a href="http://jamescooke.info/a-successful-pip-tools-workflow-for-managing-python-package-requirements.html"&gt;post sobre ele&lt;/a&gt; (EN). Então dentro desse diretório você vai encontrar os arquivos &lt;code&gt;.ini&lt;/code&gt; e &lt;code&gt;.txt&lt;/code&gt; dos requirements do projeto.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;settings&lt;ul&gt;
&lt;li&gt;Como o nome já sugere, será o módulo de configuração do projeto. Nele nós quebramos o que antes era um único &lt;code&gt;settings.py&lt;/code&gt; em 4 arquivos diferentes (na verdade são 5, eu sei, mas não vamos contar com o &lt;code&gt;__init__.py&lt;/code&gt;), cada um contendo partes específicas do settings, sendo eles:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;base.py&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__init__.py&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mail.py&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;security.py&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static.py&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dessa maneira, cobrimos as principais partes desse boilerplate. Agora um ponto importante a ressaltar é: esse projeto foi estruturado e criado para integrar o &lt;a href="https://bower.io/"&gt;bower&lt;/a&gt;, bem como facilitar o deploy de uma aplicação diretamente no &lt;a href="https://www.heroku.com/"&gt;Heroku&lt;/a&gt;. Sendo assim você vai encontrar também os sequintes arquivos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.bowerrc&lt;ul&gt;
&lt;li&gt;É o arquivo de configuração do bower. Nele vamos encontrar, por exemplo, o diretório no qual o bower deve instalar as dependências&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Procfile&lt;ul&gt;
&lt;li&gt;É o arquivo usado pelo ambiente do Heroku para declarar quais comandos vão ser executados pelos dynos da aplicação&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;app.json&lt;ul&gt;
&lt;li&gt;Arquivo também utilizado pelo Heroku para "descrever" as aplicações web que vão ser "deployadas" lá. Nesse arquivo você pode declarar variáveis de ambiente, bem como o buildpack dessa aplicação&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;bower.json&lt;ul&gt;
&lt;li&gt;Arquivo de dependências de frontend usadas pelo bower. Aqui você vai ter listado no formato JSON algumas informações, entre elas quais pacotes frontend o bower deve instalar&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;package.json&lt;ul&gt;
&lt;li&gt;Em resumo: é como se fosse o &lt;code&gt;bower.json&lt;/code&gt; só que utilizado pelo npm, no caso, para instalar o bower&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;runtime.txt&lt;ul&gt;
&lt;li&gt;Usado pelo Heroku para especificar qual versão do Python vai ser usada na criação do seu ambiente lá&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pra facilitar nossa vida, você vai encontrar também um &lt;code&gt;Makefile&lt;/code&gt; que vai conter atalhos para executar os comandos principais. Vão ser eles:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pip-compile&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;Vai atualizar os &lt;code&gt;requirements/*.txt&lt;/code&gt; com as versões mais atuais dos pacotes listados em &lt;code&gt;`requirements/*.in&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;install-dev-requirements&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;Instala os requirements&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setup-frontend&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;Instala as dependências frontend do projeto (não esqueça de rodar um &lt;code&gt;npm install&lt;/code&gt; caso não tenha ainda o bower na sua máquina)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Depois disso tudo, podemos agora ter uma visão geral de como ficou nosso boilerplate:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;tree -L 3
.
├── app.json
├── backend
│   ├── core
│   │   ├── admin.py
│   │   ├── apps.py
│   │   ├── forms.py
│   │   ├── __init__.py
│   │   ├── migrations
│   │   ├── models.py
│   │   ├── tests.py
│   │   ├── urls.py
│   │   ├── utils.py
│   │   └── views.py
│   ├── urls.py
│   └── wsgi.py
├── bin
│   └── post_compile
├── bower.json
├── example.env
├── frontend
│   ├── bower_components
│   │   ├── jquery
│   │   ├── semantic
│   │   └── susy
│   ├── scripts
│   ├── styles
│   │   └── main.scss
│   └── templates
│       ├── base.html
│       └── core
├── Makefile
├── manage.py
├── package.json
├── Procfile
├── README.md
├── requirements
│   ├── dev.in
│   ├── dev.txt
│   ├── heroku.in
│   ├── heroku.txt
│   ├── production.in
│   ├── production.txt
│   ├── test.in
│   └── test.txt
├── requirements.txt
├── runtime.txt
└── settings
    ├── base.py
    ├── __init__.py
    ├── mail.py
    ├── security.py
    └── static.py
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Eu não vou entrar em mais detalhes (como o conteúdo dos arquivos do &lt;code&gt;settings&lt;/code&gt;) porque veremos isso nos posts seguintes, como no próximo onde vou usar esse boilerplate para criar um novo projeto. Inclusive, já dando uma palhinha, essa série de posts vai ser feita em cima de um projeto bem simples: uma app Django que envia e-mails para contatos. Simples, não é? Mas dá pra fazermos um trabalho bacana e ir aprendendo juntos :)&lt;/p&gt;
&lt;p&gt;E é isso, pessoas. O link para o projeto desse boilerplate tá aqui: &lt;a href="https://github.com/dunderlabs/django-boilerplate"&gt;https://github.com/dunderlabs/django-boilerplate&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Dúvidas e/ou críticas, só visitar os comentários mais abaixo. Valeu pessoal, e até a próxima!&lt;/p&gt;</summary><category term="django"></category><category term="django-serie"></category></entry><entry><title>Criando seu ambiente isolado para desenvolvimento web com Django</title><link href="https://dunderlabs.github.io/criando-seu-ambiente-para-desenvolvimento-web-com-django.html" rel="alternate"></link><updated>2016-01-25T23:29:00-03:00</updated><author><name>Patrick Mazulo</name></author><id>tag:dunderlabs.github.io,2016-01-25:criando-seu-ambiente-para-desenvolvimento-web-com-django.html</id><summary type="html">&lt;p&gt;&lt;img alt="Créditos da imagem" src="https://dunderlabs.github.io/images/posts/criando_ambiente_django.png" /&gt;&lt;/p&gt;
&lt;p&gt;Créditos da imagem: &lt;a href="https://www.howtoforge.com/tutorial/how-to-install-django-1-9-on-ubuntu-15-04/"&gt;https://www.howtoforge.com/tutorial/how-to-install-django-1-9-on-ubuntu-15-04/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;O começo de qualquer nova atividade é sempre meio complicada. Você se vê perdido no meio de tantas possibilidades e maneiras diferentes de se fazer a mesma coisa. Se você não tiver um mínimo de mentoria, como alguém mais experiente que lhe mostre alguns macetes iniciais, ou que indique o tão famoso "caminho das pedras", essa nova estrada vai estar cheia de obstáculos que você ainda não conhece. Dentre os vários tipos de pessoas no mundo, existem aquelas que documentam essas experiências, para servir de guia para quem estará passando por ele também. E é isso que este post será. Simbora?&lt;/p&gt;
&lt;p&gt;Que Python é uma maravilha e que deveria estar na lista das maravilhas deste mundo, todo mundo já sabe. E com ele foi criado um dos mais conhecidos frameworks web: Django. Mas qual a dessa história toda de ambiente de desenvolvimento? Para ilustrar melhor, vamos imaginar o seguinte cenário:&lt;/p&gt;
&lt;p&gt;Digamos que você foi contratado para desenvolver um sistema web, e para ele você vai utilizar uma determinada versão do Django. Então você vai lá na sua máquina e instala:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;pip install &lt;span class="nv"&gt;django&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;1.6
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;Obs.: Ao não especificar a versão que será instalada, o pip irá instalar a versão mais recente e estável.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Porém nesse sistema você terá que utilizar algumas libs externas. Simples, só instalar usando o pip:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;pip install gunicorn&amp;lt;&lt;span class="o"&gt;=&lt;/span&gt;18.0 lxml&amp;lt;&lt;span class="o"&gt;=&lt;/span&gt;3.2.4
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;Obs.: Se você estiver utilizando o &lt;a href="http://www.zsh.org/"&gt;zsh&lt;/a&gt; como seu shell padrão, terá que envolver cada uma das declarações de pacote com aspas simples, ficando assim: &lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;pip install &lt;span class="s1"&gt;&amp;#39;gunicorn&amp;lt;=18.0&amp;#39;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;lxml&amp;lt;=3.2.4&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Pronto, você acaba de instalar no seu SO esses 3 pacotes, e já pode começar a desenvolver. Mas agora digamos que você também vai trabalhar em outro projeto paralelo. E agora se vê diante de um problema ao olhar as versões que terá que usar:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;django # 1.9
gunicorn # 19.4.5
lxml # 3.5
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;E agora, o que fazer? Vou ter que desinstalar as versões anteriores para instalar essas específicas deste novo projeto? E quando eu for para outro, terei que fazer isso novamente?&lt;/p&gt;
&lt;p&gt;A resposta é: Sim, caso você não use a abordagem de trabalhar com ambientes virtuais isolados.&lt;/p&gt;
&lt;p&gt;Ambiente virtual isolado é auto-explicativo. Você terá um ambiente isolado do seu sistema, onde nele você poderá ter todas as dependências instaladas para o seu projeto. Uma vez criado e instalado os pacotes, você pode iniciar seu projeto. Vai começar outro projeto com outras dependências? Beleza, só criar outro ambiente e ser feliz!&lt;/p&gt;
&lt;p&gt;Mas como começar a usar essa abordagem? Aqui que a parada começa a ficar interessante ;-)&lt;/p&gt;
&lt;p&gt;Lhes apresento o &lt;a href="https://virtualenv.readthedocs.org/en/latest/"&gt;virtualenv&lt;/a&gt; e &lt;a href="https://virtualenvwrapper.readthedocs.org/en/latest/install.html"&gt;virtualenvwrapper&lt;/a&gt;!
São duas ferramentas maravilhosas que vão possibilitar essa nova maneira de trabalhar. Mas o que é um ou outro? Vamo lá.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;virtualenv&lt;/code&gt; é uma ferramenta para criar para criar ambientes Python isolados. Para instalar é super simples:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;sudo&lt;span class="o"&gt;]&lt;/span&gt; pip install virtualenv
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;A instalação dele é feita globalmente, então dependendo do seu SO talvez seja necessário usar o &lt;code&gt;sudo&lt;/code&gt; neste comando. Ao finalizar, já podemos criar nossa primeira env:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;virtualenv minha_env
New python executable in /home/mazulo/dev/python/minha_env/bin/python
Installing setuptools, pip, wheel...done.
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;Obs.: Ao executar dessa maneira, a env criada usará como python padrão o mesmo Python que é padrão no seu SO. No caso do Ubuntu, até a versão 14.04 (a que eu uso), o Python 2.7.6 é o padrão. Sendo assim o python do &lt;code&gt;minha_env&lt;/code&gt; será o python 2.7.6. Caso você queira usar uma versão diferente, basta usar o parâmetro &lt;code&gt;-p&lt;/code&gt; (ou &lt;code&gt;--python&lt;/code&gt;) e indicar qual versão utilizar. Caso eu use a versão 3.x, ficaria dessa maneira:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;virtualenv minha_env -p python3 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Isso criará no seu diretório atual uma pasta chamada &lt;code&gt;minha_env&lt;/code&gt;. Dentro deste diretório teremos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;minha_env/lib/&lt;/strong&gt; e &lt;strong&gt;minha_env/include/&lt;/strong&gt;, contendo arquivos da biblioteca de suporte para um virtualenv python. Pacotes de terceiros (instalados via pip, por exemplo) instalados neste ambiente ficarão em &lt;strong&gt;minha_env/lib/pythonX.X/site-packages/&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;minha_env/bin/&lt;/strong&gt; é onde os executáveis ficam, como o próprio python, por exemplo. Sendo assim, executar um arquivo com &lt;code&gt;#! /caminho/para/minha_env/bin/python&lt;/code&gt; usará a versão do Python desta virtualenv.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Os pacotes principais, &lt;code&gt;pip&lt;/code&gt; e &lt;code&gt;setuptools&lt;/code&gt; já estão instalados. Dessa maneira, você pode instalar novos pacotes dentro da própria env.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;env criada, agora vamos ativá-la:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;source &lt;/span&gt;minha_env/bin/activate
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Esse comando ativará sua env. Um indicativo disso será o nome da sua env aparecer entre () antes do nome do seu usuário no seu bash.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;(&lt;/span&gt;minha_env&lt;span class="o"&gt;)&lt;/span&gt;user@machine:~&lt;span class="err"&gt;$&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Eu uso &lt;a href="http://www.zsh.org/"&gt;zsh&lt;/a&gt; com o tema fox, e ao ativar a env ele fica da seguinte maneira:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;minha_env&lt;span class="o"&gt;)&lt;/span&gt; ┌&lt;span class="o"&gt;[&lt;/span&gt;mazulo☮cabuloso&lt;span class="o"&gt;]&lt;/span&gt;-&lt;span class="o"&gt;(&lt;/span&gt;~/dev/python&lt;span class="o"&gt;)&lt;/span&gt;
└&amp;gt; &lt;span class="c"&gt;# sim, o nome do meu PC é cabuloso hahaha&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;Obs.: Daqui em diante, os exemplos do terminal serão um ctrl+c ctrl+v do meu terminal, que usa o tema citado acima.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A partir deste momento, você está totalmente isolado do seu sistema, e pode começar a instalar todas as dependências do seu projeto sem medo de ser feliz. &lt;/p&gt;
&lt;p&gt;Porém...&lt;/p&gt;
&lt;p&gt;Como você percebeu, o &lt;code&gt;virtualenv&lt;/code&gt; cria uma pasta no seu diretório atual, o que pode se tornar uma chatice, principalmente se você utilizar versionamento de código. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;"Ah, mas é só colocar essa pasta no .gitignore"&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Verdade, mas seria bem melhor não ter que fazer isso, né? Bom, uma maneira seria centralizar todas suas envs dentro de uma pasta, chamada &lt;code&gt;virtualenvs&lt;/code&gt;, por exemplo. Ela ficaria na sua home (ou onde você achar melhor). Daí sempre na hora de criar uma nova env, você navegaria até este diretório, criaria sua env, ativaria ela e depois iria para o seu diretório de trabalho... Eita, meus dedos até cansaram de digitar todo esse percurso :-P&lt;/p&gt;
&lt;p&gt;Com o tempo isso pode se tornar extremamente fatigante. Mas não perca as esperanças, pois está na hora do &lt;a href="https://virtualenvwrapper.readthedocs.org/en/latest/install.html"&gt;virtualenvwrapper&lt;/a&gt; entrar em ação!&lt;/p&gt;
&lt;p&gt;virtualenvwrapper é um conjunto de extensões para o virtualenv. Essas extensões incluem wrappers para criação e exclusão de ambientes virtuais, além de gerenciar seu workflow de desenvolvimento, tornando fácil trabalhar em mais de um projeto.&lt;/p&gt;
&lt;p&gt;Suas features:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Organizar todos os seus ambientes virtuais em um só lugar(!!!!)&lt;/li&gt;
&lt;li&gt;Wrappers para gerenciar seus ambientes (criar, deletar, copiar e etc)&lt;/li&gt;
&lt;li&gt;Usar um simples comando para trocar entre ambientes(!!!!!!!!!!!!!!)&lt;/li&gt;
&lt;li&gt;Autocomplete com tab para comandos que recebem um ambiente virtual como argumento&lt;/li&gt;
&lt;li&gt;Gatilhos configuráveis pelo usuário para todas as operações&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;dentre algumas outras.&lt;/p&gt;
&lt;p&gt;Conseguem ver a maravilha que isso é?! Acho simplesmente sensacional! E para poder usufruir de tudo isso, vamos para o passo a passo.&lt;/p&gt;
&lt;p&gt;Da mesma maneira que o &lt;code&gt;virtualenv&lt;/code&gt;, a instalação do &lt;code&gt;virtualenvwrapper&lt;/code&gt; será feita globalmente.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;sudo&lt;span class="o"&gt;]&lt;/span&gt; pip install virtualenvwrapper
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Agora nós vamos adicionar 3 linhas no arquivo de inicialização do seu shell &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;.bashrc&lt;/em&gt; ou &lt;em&gt;.profile&lt;/em&gt; para o bash padrão&lt;/li&gt;
&lt;li&gt;&lt;em&gt;.zshrc&lt;/em&gt; para zsh shell&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;export WORKON_HOME=&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;HOME&lt;/span&gt;&lt;span class="x"&gt;/.virtualenvs&lt;/span&gt;
&lt;span class="x"&gt;export PROJECT_HOME=&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;HOME&lt;/span&gt;&lt;span class="x"&gt;/Devel&lt;/span&gt;
&lt;span class="x"&gt;source /usr/local/bin/virtualenvwrapper.sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;A primeira linha configura a localização de onde seus ambientes virtuais vão ficar. Na segunda teremos a localização dos seus diretórios de projetos em desenvolvimento (pode apagar essa, se quiser), e na terceira a localização do script instalado com esse pacote. Depois disso você terá que recarregar a inicialização deste arquivo&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;source&lt;/span&gt; ~/.zshrc &lt;span class="c"&gt;# ou .bashrc, ou o arquivo que o seu shell usa&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Pronto, agora você pode criar/ativar suas envs da maneira mais simples possível :)
Exemplo executado na minha máquina:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;[&lt;/span&gt;mazulo☮cabuloso&lt;span class="o"&gt;]&lt;/span&gt;-&lt;span class="o"&gt;(&lt;/span&gt;~/dev/python&lt;span class="o"&gt;)&lt;/span&gt;
└&amp;gt; mkvirtualenv nova_env -p /usr/bin/python3.4 
Running virtualenv with interpreter /usr/bin/python3.4
Using base prefix &lt;span class="s1"&gt;&amp;#39;/usr&amp;#39;&lt;/span&gt;
New python executable in /home/mazulo/.virtualenvs/nova_env/bin/python3.4
Also creating executable in /home/mazulo/.virtualenvs/nova_env/bin/python
Installing setuptools, pip, wheel...done.
virtualenvwrapper.user_scripts creating /home/mazulo/.virtualenvs/nova_env/bin/predeactivate
virtualenvwrapper.user_scripts creating /home/mazulo/.virtualenvs/nova_env/bin/postdeactivate
virtualenvwrapper.user_scripts creating /home/mazulo/.virtualenvs/nova_env/bin/preactivate
virtualenvwrapper.user_scripts creating /home/mazulo/.virtualenvs/nova_env/bin/postactivate
virtualenvwrapper.user_scripts creating /home/mazulo/.virtualenvs/nova_env/bin/get_env_details
&lt;span class="o"&gt;(&lt;/span&gt;nova_env&lt;span class="o"&gt;)&lt;/span&gt; ┌&lt;span class="o"&gt;[&lt;/span&gt;mazulo☮cabuloso&lt;span class="o"&gt;]&lt;/span&gt;-&lt;span class="o"&gt;(&lt;/span&gt;~/dev/python&lt;span class="o"&gt;)&lt;/span&gt;
└&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Estou criando uma outra env, chamada &lt;strong&gt;nova_env&lt;/strong&gt;, agora utilizando o wrapper do &lt;code&gt;virtualenvwrapper&lt;/code&gt; chamado &lt;code&gt;mkvirtualenv&lt;/code&gt;. Ele vai criar essa env dentro do diretório que nós configuramos naquela 1ª das 3 linhas que adicionamos no arquivo de configuração do shell, e após isso já ativa ela pra nós!&lt;/p&gt;
&lt;p&gt;Agora digamos que eu vá trabalhar em outro projeto. Vou criar a env para ele:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;(&lt;/span&gt;nova_env&lt;span class="o"&gt;)&lt;/span&gt; ┌&lt;span class="o"&gt;[&lt;/span&gt;mazulo☮cabuloso&lt;span class="o"&gt;]&lt;/span&gt;-&lt;span class="o"&gt;(&lt;/span&gt;~/dev/python&lt;span class="o"&gt;)&lt;/span&gt;
└&amp;gt; mkvirtualenv django_project -p /usr/bin/python3.4 
Running virtualenv with interpreter /usr/bin/python3.4
Using base prefix &lt;span class="s1"&gt;&amp;#39;/usr&amp;#39;&lt;/span&gt;
New python executable in /home/mazulo/.virtualenvs/django_project/bin/python3.4
Also creating executable in /home/mazulo/.virtualenvs/django_project/bin/python
Installing setuptools, pip, wheel...done.
virtualenvwrapper.user_scripts creating /home/mazulo/.virtualenvs/django_project/bin/predeactivate
virtualenvwrapper.user_scripts creating /home/mazulo/.virtualenvs/django_project/bin/postdeactivate
virtualenvwrapper.user_scripts creating /home/mazulo/.virtualenvs/django_project/bin/preactivate
virtualenvwrapper.user_scripts creating /home/mazulo/.virtualenvs/django_project/bin/postactivate
virtualenvwrapper.user_scripts creating /home/mazulo/.virtualenvs/django_project/bin/get_env_details
&lt;span class="o"&gt;(&lt;/span&gt;django_project&lt;span class="o"&gt;)&lt;/span&gt; ┌&lt;span class="o"&gt;[&lt;/span&gt;mazulo☮cabuloso&lt;span class="o"&gt;]&lt;/span&gt;-&lt;span class="o"&gt;(&lt;/span&gt;~/dev/python&lt;span class="o"&gt;)&lt;/span&gt;
└&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Perceba que eu ainda estava com a &lt;strong&gt;nova_env&lt;/strong&gt; ativada ao criar a env &lt;strong&gt;django_project&lt;/strong&gt;. Mas sem problemas, o &lt;code&gt;virtualenvwrapper&lt;/code&gt; cria a env, desativa a anterior e ativa a nova pra mim :)&lt;/p&gt;
&lt;p&gt;E caso eu queira trocar de ambiente para voltar a trabalhar na nova_env? Simples:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;(&lt;/span&gt;django_project&lt;span class="o"&gt;)&lt;/span&gt; ┌&lt;span class="o"&gt;[&lt;/span&gt;mazulo☮cabuloso&lt;span class="o"&gt;]&lt;/span&gt;-&lt;span class="o"&gt;(&lt;/span&gt;~/dev/python&lt;span class="o"&gt;)&lt;/span&gt;
└&amp;gt; workon nova_env 
&lt;span class="o"&gt;(&lt;/span&gt;nova_env&lt;span class="o"&gt;)&lt;/span&gt;┌&lt;span class="o"&gt;[&lt;/span&gt;mazulo☮cabuloso&lt;span class="o"&gt;]&lt;/span&gt;-&lt;span class="o"&gt;(&lt;/span&gt;~/dev/python&lt;span class="o"&gt;)&lt;/span&gt;
└&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vou utilizar o &lt;code&gt;workon&lt;/code&gt; para trocar de maneira rápida e fácil de ambiente. O bacana é que ele permite você usar autocomplete com o tab para a env que deseja ativar. Sem trocar de diretório para isso. Sensacional, diz aí!&lt;/p&gt;
&lt;p&gt;Bom, basicamente era isso que eu gostaria de mostrar sobre o &lt;a href="https://virtualenv.readthedocs.org/en/latest/"&gt;virtualenv&lt;/a&gt; e &lt;a href="https://virtualenvwrapper.readthedocs.org/en/latest/install.html"&gt;virtualenvwrapper&lt;/a&gt;, e como configurar um ambiente para começar a trabalhar com django.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;"Ah, mas você nem falou como instalar o django"&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Super fácil, ora pois:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;(&lt;/span&gt;django_project&lt;span class="o"&gt;)&lt;/span&gt; ┌&lt;span class="o"&gt;[&lt;/span&gt;mazulo☮cabuloso&lt;span class="o"&gt;]&lt;/span&gt;-&lt;span class="o"&gt;(&lt;/span&gt;~/dev/python&lt;span class="o"&gt;)&lt;/span&gt;
└&amp;gt; pip install django
Collecting django
  Downloading Django-1.9.1-py2.py3-none-any.whl &lt;span class="o"&gt;(&lt;/span&gt;6.6MB&lt;span class="o"&gt;)&lt;/span&gt;
    100% &lt;span class="p"&gt;|&lt;/span&gt;████████████████████████████████&lt;span class="p"&gt;|&lt;/span&gt; 6.6MB 181kB/s 
Installing collected packages: django
Successfully installed django-1.9.1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Pronto, django instalado de maneira isolada no seu ambiente. Agora só começar a codar!&lt;/p&gt;
&lt;p&gt;Dúvidas e/ou críticas, só visitar os comentários mais abaixo. Valeu pessoal, e até a próxima!&lt;/p&gt;
&lt;p&gt;Referências:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://virtualenv.readthedocs.org/en/latest/index.html"&gt;Virtualenv&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://virtualenvwrapper.readthedocs.org/en/latest/"&gt;virtualenvwrapper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="python"></category><category term="django"></category><category term="django environment"></category><category term="web development"></category></entry><entry><title>Série Django - Settings</title><link href="https://dunderlabs.github.io/serie-django-settings.html" rel="alternate"></link><updated>2016-01-17T21:34:00-03:00</updated><author><name>Patrick Mazulo</name></author><id>tag:dunderlabs.github.io,2016-01-17:serie-django-settings.html</id><summary type="html">&lt;p&gt;&lt;img alt="Créditos da imagem" src="https://dunderlabs.github.io/images/posts/django-settings.jpg" /&gt;  &lt;/p&gt;
&lt;p&gt;Créditos da imagem: &lt;a href="https://www.coderedcorp.com/blog/django-settings-for-multiple-environments/"&gt;https://www.coderedcorp.com/blog/django-settings-for-multiple-environments/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Estaremos iniciando uma nova série no blog. Mas vamos tentar fazer de uma maneira diferente. Ao invés de criarmos uma aplicação, vamos falar sobre o Django em si, seus componentes, como funcionam, como se interrelacionam e etc. O post de hoje na realidade é uma "transcrição" de um hangout que aconteceu há um tempo atrás, de um grupo de estudo no Telegram chamado "Django Group - Initial Steps". Caso tenha interesse, &lt;a href="http://pastebin.com/nwYyG7Ar"&gt;neste link&lt;/a&gt; vc terá informações sobre como se juntar ao grupo.&lt;/p&gt;
&lt;p&gt;Neste &lt;a href="https://youtu.be/m7PujnjPboU"&gt;hangout&lt;/a&gt; em questão falamos sobre o módulo &lt;code&gt;settings.py&lt;/code&gt;. Então, vamos discutir um pouco sobre ele aqui neste post.&lt;/p&gt;
&lt;p&gt;O &lt;code&gt;settings.py&lt;/code&gt; nada mais é do que um arquivo de configuração do Django que contém todas as configurações da sua instalação do framework. Esse arquivo nada mais é do que também um módulo Python com váriaveis de nível de módulo.&lt;/p&gt;
&lt;p&gt;Agora vamos percorrer suas linhas e entender o que cada uma faz.&lt;/p&gt;
&lt;p&gt;Ao início do arquivo, você terá uma string de múltiplas linhas, com informações relevantes, incluindo links da documentação para você depois ter mais informações sobre este arquivo.
Agora vamos trazer atenção para estas linhas:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;span class="n"&gt;BASE_DIR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dirname&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dirname&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;abspath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__file__&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;O que está acontecendo? E para que serve esta variável &lt;code&gt;BASE_DIR&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;O módulo &lt;code&gt;os&lt;/code&gt; do Python nos fornece uma maneira portável de usar funcionalidades do sistema operacional. No caso estaremos usando para manipular caminhos de diretórios (paths).&lt;/p&gt;
&lt;p&gt;BASE_DIR é a variável que vai ter o caminho para o nosso projeto Django, e será usada mais a frente. Serve como uma maneira facilitada para que não tenhamos que trabalhar com caminho absoluto (absolute paths). Imagine que você salve o caminho para o seu projeto com o caminho absoluto como  &lt;code&gt;BASE_DIR = '/home/&amp;lt;user&amp;gt;/dev/django_projects/my_project'&lt;/code&gt;, e por algum motivo tenha que mudar seu projeto para outra máquina. Quanta dor de cabeça seria para mudar todos os arquivos onde você precise desse caminho? Pois bem, o settings, ao iniciar o projeto, já vem com uma abordagem bem bacana para facilitar e nos livrar desse imenso trabalho.&lt;/p&gt;
&lt;p&gt;Mas para entender melhor vamos pedaço por pedaço.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;__file__&lt;/code&gt; é um atributo do módulo atual que representa o nome do arquivo. Faça um teste: salve um arquivo .py apenas com um &lt;code&gt;print(__file__)&lt;/code&gt; e execute-o para ver o que será printado na tela.
Este vai ser o ponto de partida para descobrirmos o restante do caminho para o projeto.
Agora vamos realizar as chamadas dos métodos de dentro para fora, para podermos ver como vamos conseguir realizar tal façanha.&lt;/p&gt;
&lt;p&gt;A chamada mais interna é esta: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;abspath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__file__&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;O &lt;code&gt;abspath&lt;/code&gt; vai nos retornar uma versão absoluta e normalizada do caminho deste arquivo (arquivo este disponibilizado pelo &lt;code&gt;__file__&lt;/code&gt;, lembra?). Digamos que na minha máquina eu tenha um projeto django chamado "django_project_1_9". O &lt;code&gt;abspath&lt;/code&gt; retornaria o seguinte caminho:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;/home/mazulo/dev/web/django_projects/django_project_1_9/django_project_1_9/settings.py
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Perceba que ao final do arquivo nós temos o próprio arquivo &lt;code&gt;settings.py&lt;/code&gt;. Pois bem, o resultado desta chamada vai ser imediatamente jogado para a chamada mais externa, que no caso é o:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dirname&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;abspath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__file__&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;O &lt;code&gt;dirname&lt;/code&gt; vai retorna o nome do diretório pai do caminho passado ao diretório. Vai ser o primeiro elemento do par retornado ao passar este path para a função &lt;code&gt;os.path.split()&lt;/code&gt;. O resultado será:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;/home/mazulo/dev/web/django_projects/django_project_1_9/django_project_1_9
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Note que ele apenas retirou o nome do arquivo &lt;code&gt;settings.py&lt;/code&gt;. Este é o diretório onde está o arquivo &lt;code&gt;settings.py&lt;/code&gt;, ainda não é a raiz do nosso projeto, nosso atual objetivo. O resultado dessa chamada será então jogado como parâmetro para a última função encadeada:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;BASE_DIR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dirname&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dirname&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;abspath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__file__&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Usamos novamente o &lt;code&gt;dirname&lt;/code&gt; para pegar o diretório pai. Uma vez o último diretório era onde está armazenado o settings, acima dele teremos a raiz do nosso projeto, onde também está o arquivo &lt;code&gt;manage.py&lt;/code&gt;. E é exatamente isso que será retornado e atribuído para a variável &lt;code&gt;BASE_DIR&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;/home/mazulo/dev/web/django_projects/django_project_1_9
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Pronto, aí está o caminho para a raiz do nosso projeto sendo setada de maneira dinâmica. Agora, independente de quantas vezes trocarmos nosso projeto de pasta/máquina, este caminho estará funcionando perfeitamente.&lt;/p&gt;
&lt;p&gt;Seguindo em frente teremos o &lt;code&gt;DEBUG&lt;/code&gt;. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;DEBUG&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Sua função basicamente é mostrar informações detalhadas em uma página sobre o erro ocorrido. Lembra daquela página amarela?&lt;/p&gt;
&lt;p&gt;&lt;img alt="Exemplo da página de erro" src="https://dunderlabs.github.io/images/posts/django_page_error.png" /&gt;&lt;/p&gt;
&lt;p&gt;Mas não somente na documentação, como em qualquer post você vai encontrar o seguinte conseglho: &lt;strong&gt;NUNCA&lt;/strong&gt; faça deploy de um sistema com o modo &lt;code&gt;DEBUG&lt;/code&gt; ligado. &lt;strong&gt;NUNCA&lt;/strong&gt;. O motivo é que nessa tela de erro, junto com o traceback do erro, são mostradas muitos metadados sobre o seu ambiente, assim como o que está definido no seu settings. Então, fica dado o recado: &lt;strong&gt;NUNCA&lt;/strong&gt; &lt;em&gt;faça deploy de um sistema com o modo &lt;code&gt;DEBUG&lt;/code&gt; ligado.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Logo após a declaração do &lt;code&gt;BASE_DIR&lt;/code&gt;, teremos o &lt;code&gt;ALLOWED_HOSTS&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ALLOWED_HOSTS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;O &lt;code&gt;ALLOWED_HOSTS&lt;/code&gt; é uma lista de strings representando o host/nome de domínio que o projeto Django pode servir. Serve como uma medida de segurança para impedir que um invasor possa realizar certos tipos de ataque (evenenamento de cache, disparo de e-mails de redefinição de senha contendo links para hosts maliciosos e etc).&lt;/p&gt;
&lt;p&gt;Seguindo em frente teremos uma das mais conhecidas variáveis deste módulo, e primeiramente modificadas ao início de um projeto: &lt;code&gt;INSTALLED_APPS&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# Application definition&lt;/span&gt;

&lt;span class="n"&gt;INSTALLED_APPS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;django.contrib.admin&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;django.contrib.auth&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;django.contrib.contenttypes&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;django.contrib.sessions&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;django.contrib.messages&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;django.contrib.staticfiles&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;myapp&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;INSTALLED_APPS&lt;/code&gt; é uma lista de strings designando todas as aplicações que estão habilitadas nesta instalação do Django. Cada string deve ser um caminho Python (com pontos, algo como 'module.class') para:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Uma classe de configuração de aplicação, ou&lt;/li&gt;
&lt;li&gt;Um pacote contendo uma aplicação (o caso daquele 'myapp')&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Logo após teremos o &lt;code&gt;MIDDLEWARE_CLASSES&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;MIDDLEWARE_CLASSES&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;django.middleware.security.SecurityMiddleware&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;django.contrib.sessions.middleware.SessionMiddleware&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;django.middleware.common.CommonMiddleware&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;django.middleware.csrf.CsrfViewMiddleware&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;django.contrib.auth.middleware.AuthenticationMiddleware&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;django.contrib.auth.middleware.SessionAuthenticationMiddleware&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;django.contrib.messages.middleware.MessageMiddleware&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;django.middleware.clickjacking.XFrameOptionsMiddleware&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;O &lt;code&gt;MIDDLEWARE_CLASSES&lt;/code&gt; é uma lista de classes Middleware que serão usadas no seu projeto Django. Middleware na realidade é um framework do Django, que tem um conjunto de classes que servem como "gatilhos" para processar e modificar request/response. Cada componente é responsável por fazer alguma coisa em específico. Por exemplo, é por causa do &lt;code&gt;'django.contrib.auth.middleware.AuthenticationMiddleware'&lt;/code&gt; que você consegue ter acesso ao usuário da requisição (&lt;code&gt;request.user&lt;/code&gt;, para ver o código do Django responsável por isso, &lt;a href="https://github.com/django/django/blob/master/django/contrib/auth/middleware.py#L22"&gt;clique aqui&lt;/a&gt;), e também ao dicionário session (&lt;code&gt;request.session&lt;/code&gt;), tendo a classe &lt;code&gt;'django.contrib.sessions.middleware.SessionMiddleware'&lt;/code&gt; como responsável por isso. A ordem em que está configurado realmente importa, porque um middleware pode depender de outro. Por exemplo os que citamos aqui: a classe &lt;code&gt;AuthenticationMiddleware&lt;/code&gt; armazena o usuário na sessão, então ele deve rodar depois do &lt;code&gt;SessionMiddleware&lt;/code&gt;. Tudo beleza? Próximo, então.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TEMPLATES&lt;/code&gt; é uma lista de configuraçẽs para todas as engines de templates a serem usadas pelo Django. Cada item da lista é um dicionário contendo as opções para uma única engine. Neste dicionário teremos as seguintes chaves para sua configuração:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;TEMPLATES&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="s"&gt;&amp;#39;BACKEND&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;django.template.backends.django.DjangoTemplates&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s"&gt;&amp;#39;DIRS&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BASE_DIR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;templates&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),],&lt;/span&gt;
        &lt;span class="s"&gt;&amp;#39;APP_DIRS&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s"&gt;&amp;#39;OPTIONS&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="s"&gt;&amp;#39;context_processors&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
                &lt;span class="s"&gt;&amp;#39;django.template.context_processors.debug&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="s"&gt;&amp;#39;django.template.context_processors.request&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="s"&gt;&amp;#39;django.contrib.auth.context_processors.auth&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="s"&gt;&amp;#39;django.contrib.messages.context_processors.messages&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="p"&gt;],&lt;/span&gt;
        &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;BACKEND&lt;/code&gt;: o backend/engine que será usado para renderizar os templates. Por padrão é usado o &lt;code&gt;DjangoTemplates&lt;/code&gt;, mas você pode trocar e usar o &lt;code&gt;Jinja2&lt;/code&gt; no lugar, que também já vem por padrão. Você também pode usar alguma outra engine de terceiros, basta indicar o caminho completo: &lt;code&gt;'mypackage.whatever.Backend'&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DIRS&lt;/code&gt;: Diretórios onde a engine vai procurar por arquivos de templates, em ordem de pesquisa.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;APP_DIRS&lt;/code&gt;: Valor booleano que vai indicar se a engine deve procurar por arquivos de templates dentro das aplicações instaladas no projeto.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;OPTIONS&lt;/code&gt;: Um dicionário que servirá como parâmetros extras para passar ao backend do template. Esses parâmetros podem variar dependendo do backend. Por padrão virá apenas com apenas uma chave-valor, chamado &lt;code&gt;context_processors&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;context_processors&lt;/code&gt; é uma lista de objetos chamáveis que são usados para popular o contexto no objeto &lt;code&gt;RequestContext&lt;/code&gt;. Esses chamáveis recebem um objeto request como argumento e retornam um dicionário de item para serem incorporados no contexto.&lt;/p&gt;
&lt;p&gt;Vamos aos &lt;code&gt;WSGI_APPLICATION&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;WSGI_APPLICATION&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;django_project_1_9.wsgi.application&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;É o caminho Python completo para o objeto WSGI da aplicação que os servidores built-in (&lt;code&gt;runserver&lt;/code&gt;, por exemplo) do Django vão usar. Ao executar o &lt;code&gt;django-admin.py startproject&lt;/code&gt;, o comando vai criar um arquivo &lt;code&gt;wsgi.py&lt;/code&gt; simples com um &lt;code&gt;application&lt;/code&gt; chamável e apontar essa configuração para essa &lt;code&gt;application&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Agora chegamos em outro também muito importante, o &lt;code&gt;DATABASES&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# Database&lt;/span&gt;
&lt;span class="c"&gt;# https://docs.djangoproject.com/en/1.9/ref/settings/#databases&lt;/span&gt;

&lt;span class="n"&gt;DATABASES&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;default&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="s"&gt;&amp;#39;ENGINE&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;django.db.backends.sqlite3&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s"&gt;&amp;#39;NAME&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BASE_DIR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;db.sqlite3&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Nada mais é do que um dicionário de dicionários (dicionário aninhado) onde cada dicionário contém as configurações para uso de um banco de dados, possibilitando assim o uso de múltiplos banco num mesmo projeto. A configuração mais simples para esta variável encontra-se no &lt;code&gt;default&lt;/code&gt; gerado pelo &lt;code&gt;django-admin.py&lt;/code&gt; (snippet acima).&lt;/p&gt;
&lt;p&gt;Seguindo em frente teremos o &lt;code&gt;AUTH_PASSWORD_VALIDATORS&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# Password validation&lt;/span&gt;
&lt;span class="c"&gt;# https://docs.djangoproject.com/en/1.9/ref/settings/#auth-password-validators&lt;/span&gt;

&lt;span class="n"&gt;AUTH_PASSWORD_VALIDATORS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="s"&gt;&amp;#39;NAME&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;django.contrib.auth.password_validation.UserAttributeSimilarityValidator&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="s"&gt;&amp;#39;NAME&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;django.contrib.auth.password_validation.MinimumLengthValidator&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="s"&gt;&amp;#39;NAME&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;django.contrib.auth.password_validation.CommonPasswordValidator&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="s"&gt;&amp;#39;NAME&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;django.contrib.auth.password_validation.NumericPasswordValidator&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;É uma lisa de validadores que são usados para checar a força da senha do usuário. O Django já disponibiliza alguns por padrão, mas nada o impede de criar os seus próprios e usar nesta configuração.&lt;/p&gt;
&lt;p&gt;Internacionalização:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# Internationalization&lt;/span&gt;
&lt;span class="c"&gt;# https://docs.djangoproject.com/en/1.9/topics/i18n/&lt;/span&gt;

&lt;span class="n"&gt;LANGUAGE_CODE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;en-us&amp;#39;&lt;/span&gt;

&lt;span class="n"&gt;TIME_ZONE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;UTC&amp;#39;&lt;/span&gt;

&lt;span class="n"&gt;USE_I18N&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;

&lt;span class="n"&gt;USE_L10N&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;

&lt;span class="n"&gt;USE_TZ&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vamos por partes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;LANGUAGE_CODE&lt;/code&gt;: Uma string que representa o código do idioma para esta instalação. Esse código tem de estar de acordo com o &lt;a href="https://docs.djangoproject.com/en/1.9/topics/i18n/#term-language-code"&gt;formato padrão de ID de linguagem&lt;/a&gt;. Essa variável tem dois propósitos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Se o locale middleware não está em uso, ele vai decidir qual tradução vai ser servida para todos os usuários&lt;/li&gt;
&lt;li&gt;Se o locale middleware está ativado, ele fornece um idioma como fallback no caso do idioma escolhido pelo usuário não puder ser determinado, ou não for suportado pelo website.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;TIME_ZONE&lt;/code&gt;: Uma string representando a time zone para essa instalação. Essa não necessariamente vai ser a time zone do server. Um servidor pode servir múltiplos projetos Django, cada um com sua configuração de time zone separada. Ao usar &lt;code&gt;USE_TZ&lt;/code&gt; como &lt;code&gt;False&lt;/code&gt;, essa será a time zone na qual Django vai armazenar todos os horários (datetimes). Já quando o &lt;code&gt;USE_TZ&lt;/code&gt; está setado como &lt;code&gt;True&lt;/code&gt;, esse vai ser a time zone padrão que o Django vai usar para mostrar horários em templates, e interpretar datas/horários submetidos em forms.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;USE_TZ&lt;/code&gt;: Um boolean que indica se datas/horários serão reconhecidos pela timezone, ou não. Se for &lt;code&gt;True&lt;/code&gt;, então o Django vai usar esse reconhecimento de datetimes internamente. Caso contrário, Django vai usar datetimes no tempo local.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;USE_I18N&lt;/code&gt;: Um boolean indicando se o sistema de tradução do Django deve ser habilitado.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;USE_L10N&lt;/code&gt;: Indica se os dados devem ser formatados levando em consideração sua localização. Se for &lt;code&gt;True&lt;/code&gt;, Django vai mostrar números e datas usando o formato local atual.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;E por fim, ao final do &lt;code&gt;settings.py&lt;/code&gt; padrão gerado pelo &lt;code&gt;django-admin.py&lt;/code&gt;, teremos o &lt;code&gt;STATIC_URL&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# Static files (CSS, JavaScript, Images)&lt;/span&gt;
&lt;span class="c"&gt;# https://docs.djangoproject.com/en/1.9/howto/static-files/&lt;/span&gt;

&lt;span class="n"&gt;STATIC_URL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;/static/&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vai ser a URL usada para se referir aos arquivos estáticos localizados no &lt;code&gt;STATIC_ROOT&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Exemplo: "/static/" (como no snippet acima), ou "http://static.server.com/"&lt;/p&gt;
&lt;p&gt;Digamos que seus arquivos estáticos estão dentro do seu projeto Django, que seu &lt;code&gt;STATIC_URL&lt;/code&gt; é "static", e que seu site se chama "http://meusite.com". No seu projeto você tem uma pasta "staticfiles" onde há um diretório para imagens chamado "img/". Ao acessar pela web a URL de alguma imagem do seu site, o caminho seria algo como: &lt;code&gt;http://meusite.com/static/img/imagem.jpg&lt;/code&gt;. Sacou? :)&lt;/p&gt;
&lt;p&gt;Bom pessoal, por enquanto é isso. Ainda tem &lt;strong&gt;MUITA&lt;/strong&gt; coisa, que se eu fosse cobrir tornaria este post gigantescamente maior do que ficou hahaha. Caso tenha curiosidade, não esqueça de visitar a documentação.
E se você curtiu esse post, compartilhe com os amigos devs! :D&lt;/p&gt;
&lt;p&gt;PS.: Há um python packate muito bacana chamado &lt;a href="https://github.com/drgarcia1986/simple-settings"&gt;simple-settings&lt;/a&gt;, desenvolvido pelo &lt;a href="https://twitter.com/drgarcia1986"&gt;@drgarcia1986&lt;/a&gt;, com o intuito de facilitar a maneira como você gerencia os settings dos projetos. Vale a pena dar uma olhada.&lt;/p&gt;
&lt;p&gt;Valeu pessoal, e até a próxima!&lt;/p&gt;
&lt;p&gt;Referências:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.djangoproject.com/en/1.9/topics/settings/"&gt;Documentação Django - settings&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.djangobook.com/en/2.0/chapter17.html"&gt;Django Book&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.djangoproject.com/en/1.9/_images/middleware.svg"&gt;Image how middleware works&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://agiliq.com/blog/2015/07/understanding-django-middlewares/"&gt;Understanding django middlewares&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/20957388/what-is-a-context-in-django"&gt;What is a context in django&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.b-list.org/weblog/2006/jun/14/django-tips-template-context-processors/"&gt;Django tips: Template context processors&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="python"></category><category term="django"></category><category term="django settings"></category><category term="web development"></category></entry></feed>